第1篇-关于运行时，开篇说的简单些
不过由于Java方法与C/C++函数的调用约定不同，所以并不能直接调用，需要JavaCalls::call()这个函数辅助调用
从C/C++方法中调用的一些Java方法主要有：
（1）Java主类中的main()方法；
（2）Java主类装载时，调用JavaCalls::call()函数执行checkAndLoadMain()方法；
（3）类的初始化过程中，调用JavaCalls::call()函数执行的Java类初始化方法<clinit>，可以查看JavaCalls::call_default_constructor()函数，有对<clinit>方法的调用逻辑；
（4）我们先省略main方法的执行流程（其实main方法的执行也是通过JLI_Launch先启动一个JavaMain线程，套路都是一样的），单看某个JavaThread的启动过程。
JavaThread的启动最终都要通过一个native方法java.lang.Thread#start0()完成的，这个方法经过解释器的native_entry入口，调用到了JVM_StartThread()函数。
其中的static void thread_entry(JavaThread* thread, TRAPS)函数中会调用JavaCalls::call_virtual()函数。JavaThread最终会通过JavaCalls::call_virtual()函数来调用字节码中的run()方法；
（5）在SystemDictionary::load_instance_class()这个能体现双亲委派的函数中，如果类加载器对象不为空，则会调用这个类加载器的loadClass()函数（通过call_virtual()函数来调用）来加载类。

// HotSpot VM里对JNI的CallStaticVoidMethod的实现。留意要传给Java方法的参数以C的可变长度参数传入，这个函数将其收集打包为JNI_ArgumentPusherVaArg对象
-> jni_CallStaticVoidMethod() 
 
	// 这里进一步将要传给Java的参数转换为JavaCallArguments对象传下去 
	-> jni_invoke_static() 
   
	    // 真正底层实现的开始。这个方法只是层皮，把JavaCalls::call_helper()用os::os_exception_wrapper()包装起来，目的是设置HotSpot VM的C++层面的异常处理
	    -> JavaCalls::call()
	 
	       -> JavaCalls::call_helper()
	          -> //... 检查目标方法是否为空方法，是的话直接返回
	          -> //... 检查目标方法是否“首次执行前就必须被编译”，是的话调用JIT编译器去编译目标方法
	          -> //... 获取目标方法的解释模式入口from_interpreted_entry，下面将其称为entry_point
	          -> //... 确保Java栈溢出检查机制正确启动
	          -> //... 创建一个JavaCallWrapper，用于管理JNIHandleBlock的分配与释放，以及在调用Java方法前后保存和恢复Java的frame pointer/stack pointer

	          //... StubRoutines::call_stub()返回一个指向call stub的函数指针，
	          // 紧接着调用这个call stub，传入前面获取的entry_point和要传给Java方法的参数等信息
	          -> StubRoutines::call_stub()(...) 
	             // call stub是在VM初始化时生成的。对应的代码在StubGenerator::generate_call_stub()函数中
	             -> //... 把相关寄存器的状态调整到解释器所需的状态
	             -> //... 把要传给Java方法的参数从JavaCallArguments对象解包展开到解释模式calling convention所要求的位置
	             -> //... 跳转到前面传入的entry_point，也就是目标方法的from_interpreted_entry

	                -> //... 在-Xcomp模式下，实际跳入的是i2c adapter stub，将解释模式calling convention传入的参数挪到编译模式calling convention所要求的位置
	                       -> //... 跳转到目标方法被JIT编译后的代码里，也就是跳到 nmethod 的 VEP 所指向的位置
	                            -> //... 正式开始执行目标方法被JIT编译好的代码 <- 这里就是"main()方法的真正入口"

第2篇-关于运行时的call_helper()函数
native方法的栈帧、Java解释栈帧和Java编译栈帧都会在宿主栈中分配，这些不同的栈帧都紧密的挨在一起
调用call_stub()返回的函数，需要传递8个参数。如下：
link 此变量的类型为JavaCallWrapper，这个变量对于栈展开过程非常重要，后面会详细介绍；
result_val_address 函数返回值地址；
result_type 函数返回类型；
method() 当前要执行的方法。通过此参数可以获取到Java方法所有的元数据信息，包括最重要的字节码信息，这样就可以根据字节码信息解释执行这个方法了；
entry_point HotSpot每次在调用Java函数时，必然会调用CallStub函数指针，这个函数指针的值取自_call_stub_entry，HotSpot通过_call_stub_entry指向被调用函数地址。在调用函数之前，必须要先经过entry_point，HotSpot实际是通过entry_point从method()对象上拿到Java方法对应的第1个字节码命令，这也是整个函数的调用入口；
args->parameters() 描述Java函数的入参信息；
args->size_of_parameters() 描述Java函数的入参数量；
CHECK 当前线程对象

第3篇-CallStub新栈帧的创建
static CallStub call_stub(){
	return (CallStub)( 
    	unsigned int(_call_stub_entry) );
}
_call_stub_entry的生成:
JavaMain()
InitializeJVM()
JNI_CreateJavaVM()
Threads::create_vm() 	 	
init_globals()
stubRoutines_init1()
StubRoutines::initialize1() 	
StubGenerator_generate()
StubGenerator::StubGenerator() 	 	 	
StubGenerator::generate_initial()
StubRoutines::_call_stub_entry = generate_call_stub(
        StubRoutines::_call_stub_return_address
);

第4篇-JVM终于开始调用Java主类的main()方法
空
第5篇-调用Java方法后弹出栈帧及处理返回结果
统合这一篇和前几篇文章，我们应该学习到C/C++的调用约定以及Java方法在解释执行下的调用约定

第6篇-Java方法新栈帧的创建
from_interpreted_entry通过Method::link_method函数从_entry_table读取到对应的entry进行赋值，而_entry_table的生成则通过以下调用栈:
JavaMain()
InitializeJVM()
JNI_CreateJavaVM()
Threads::create_vm()
init_globals()
interpreter_init()
TemplateInterpreter::initialize() 	
InterpreterGenerator::InterpreterGenerator()
TemplateInterpreterGenerator::generate_all()
AbstractInterpreterGenerator::generate_method_entry
address InterpreterGenerator::generate_normal_entry(bool synchronized) {

		// ...

		// entry_point函数的代码入口地址
		address entry_point = __ pc(); 		

		// 当前rbx中存储的是指向Method的指针，
		// 通过Method*找到ConstMethod*
		const	Address constMethod(rbx,Method::const_offset()); 

		// 通过Method*找到AccessFlags
		const	Address access_flags(rbx,
								Method::access_flags_offset()); 

		// 通过ConstMethod*得到parameter的大小
		const	Address size_of_parameters(
								rdx,ConstMethod::size_of_parameters_offset());

		// 通过ConstMethod*得到local变量的大小
		const	Address size_of_locals(rdx, 
									ConstMethod::size_of_locals_offset());		

		// 上面已经说明了获取各种方法元数据的计算方式，
		// 但并没有执行计算，下面会生成对应的汇编来执行计算
		// 计算ConstMethod*，保存在rdx里面
		__ movptr(rdx, constMethod); 

		// 计算parameter大小，保存在rcx里面 
		__ load_unsigned_short(rcx, size_of_parameters);	

		// rbx：保存基址；rcx：保存循环变量；
		// rdx：保存目标地址；rax：保存返回地址（下面用到）
		// 此时的各个寄存器中的值如下：
		// rbx: Method*
		// rcx: size of parameters
		// r13: 
		// sender_sp (could differ from sp+wordSize 
		// if we were called via c2i ) 即调用者的栈顶地址
		// 计算local变量的大小，保存到rdx
		__ load_unsigned_short(rdx, size_of_locals);

		// 由于局部变量表用来存储传入的参数和被调
		// 用方法的局部变量，所以rdx减去
		// rcx后就是被调用方法的局部变量可使用的大小 
		__ subl(rdx, rcx); 

		// ... 

		// 返回地址是在CallStub中保存的，如果不弹
		// 出堆栈到rax，中间会有个
		// return address使的局部变量表不是连续的，
		// 这会导致其中的局部变量计算方式不一致，所以
		// 暂时将返回地址存储到rax中
		__ pop(rax); 

		// 计算第1个参数的地址：
		// 当前栈顶地址 + 变量大小 * 8 - 一个字大小
		// 注意，因为地址保存在低地址上，而堆栈是向低
		// 地址扩展的，所以只需加n-1个
		// 变量大小就可以得到第1个参数的地址
		__ lea(r14, Address(rsp, rcx, Address::times_8, -wordSize)); 

		// 把函数的局部变量设置为0,也就是做初始化，
		// 防止之前遗留下的值影响
		// rdx：被调用方法的局部变量可使用的大小
		{
				Label exit, loop;
				__ testl(rdx, rdx);
				// 如果rdx<=0，不做任何操作
				__ jcc(Assembler::lessEqual, exit); 
				__ bind(loop);
				// 初始化局部变量
				__ push((int)	NULL_WORD); 
				__ decrementl(rdx); 
				__ jcc(Assembler::greater, loop);
				__ bind(exit);
		} 

		// 生成固定桢
		generate_fixed_frame(false); 
	
		// ... 省略统计及栈溢出等逻辑，后面会详细介绍 
		// 如果是同步方法时，还需要执行lock_method()
		// 函数，所以会影响到栈帧布局 
		if	(synchronized) {
				lock_method();
		} 

		// 跳转到目标Java方法的第一条字节码指令，
		// 并执行其对应的机器指令
        __ dispatch_next(vtos); 

		// ... 省略统计相关逻辑，后面会详细介绍 
		return	entry_point;
}

第7篇-为Java创建帧栈
void TemplateInterpreterGenerator::generate_fixed_frame(bool native_call) {
	// 把返回地址紧接着局部变量区保存
	__ push(rax); 
	// 为Java方法创建栈帧 
	__ enter(); 
	// 保存调用者的栈顶地址 
	__ push(r13); 
	// 暂时将last_sp属性的值设置为NULL_WORD 
	__ push((int)NULL_WORD);
	// 获取ConstMethod*并保存到r13中
	__ movptr(r13, Address(rbx, Method::const_offset())); 
	// 保存Java方法字节码的地址到r13中
	__ lea(r13, Address(r13, ConstMethod::codes_offset())); 
	// 保存Method*到堆栈上
	__ push(rbx);   

	// ProfileInterpreter属性的默认值为true，
	// 表示需要对解释执行的方法进行相关信息的统计
	if (ProfileInterpreter) {
		Label method_data_continue;
		// MethodData结构基础是ProfileData，
		// 记录函数运行状态下的数据
		// MethodData里面分为3个部分，
		// 一个是函数类型等运行相关统计数据，
		// 一个是参数类型运行相关统计数据，
		// 还有一个是extra扩展区保存着
		// deoptimization的相关信息
		// 获取Method中的_method_data属性的值并保存到rdx中
		__ movptr(rdx, Address(rbx, in_bytes(Method::method_data_offset())));

		__ testptr(rdx, rdx);
		__ jcc(Assembler::zero, method_data_continue);
		// 执行到这里，说明_method_data已经进行了初始化，
		// 通过MethodData来获取_data属性的值并存储到rdx中
		__ addptr(rdx, in_bytes(MethodData::data_offset()));
		__ bind(method_data_continue);
		__ push(rdx); 

	} else {
		__ push(0);
	}


	// 获取ConstMethod*存储到rdx
	__ movptr(rdx, Address(rbx, 
	    Method::const_offset()));
	// 获取ConstantPool*存储到rdx
	__ movptr(rdx, Address(rdx, 
	     ConstMethod::constants_offset())); 
	// 获取ConstantPoolCache*并存储到rdx
	__ movptr(rdx, Address(rdx, 
	     ConstantPool::cache_offset_in_bytes())); 
	// 保存ConstantPoolCache*到堆栈上
	__ push(rdx); 
	// 保存第1个参数的地址到堆栈上
	__ push(r14); 


	if (native_call) {
		// native方法调用时，不需要保存Java
		// 方法的字节码地址，因为没有字节码
		__ push(0); 
	} else {
		// 保存Java方法字节码地址到堆栈上，
		// 注意上面对r13寄存器的值进行了更改
		__ push(r13);
	}


	// 预先保留一个slot，后面有大用处
	__ push(0); 
	// 将栈底地址保存到这个slot上
	__ movptr(Address(rsp, 0), rsp); 

}
generate_fixed_frame执行后寄存器的状态:
rbx：Method*
ecx：invocation counter
r13：bcp(byte code pointer)
rdx：ConstantPool* 常量池的地址
r14：本地变量表第1个参数的地址

第8篇-dispatch_next()函数分派字节码
// 从generate_fixed_frame()函数生成
// Java方法调用栈帧的时候，
// 如果当前是第一次调用，那么r13指向
// 的是字节码的首地址，
// 即第一个字节码，此时的step参数为0
void InterpreterMacroAssembler::dispatch_next(TosState	state, int	step) { 
		load_unsigned_byte(rbx, Address(r13, step)); 
		// 在当前字节码的位置，指针向前移动step宽度，
		// 获取地址上的值，这个值是Opcode（范围1~202），
		// 存储到rbxstep的值由字节码指令
		// 和它的操作数共同决定
		// 自增r13供下一次字节码分派使用
		increment(r13, step); 

		// 返回当前栈顶状态的所有字节码入口点
		dispatch_base(state, Interpreter::dispatch_table(state));
}

void	InterpreterMacroAssembler::dispatch_base(
		TosState		state, // 表示栈顶缓存状态
		address* table,
		bool	verifyoop
) {

		// ...

		// 获取当前栈顶状态字节码转发表
		// 的地址，保存到rscratch1
		lea(rscratch1, ExternalAddress((address)table));
		// 跳转到字节码对应的入口执行机器码指令
		// address = rscratch1 + rbx * 8
		jmp(Address(rscratch1, rbx, Address::times_8));
}

dispatch_next生成的汇编:

// 在generate_fixed_frame()函数中
// 已经让%r13存储了bcp
// %ebx中存储的是字节码的Opcode，也就是操作码
movzbl 0x0(%r13),%ebx 
		
// $0x7ffff73ba4a0这个地址指向的
// 是对应state状态(out tos)下的一维数组，长度为256
movabs $0x7ffff73ba4a0,%r10

// 注意%r10中存储的是常量，根据计算公式
// %r10+%rbx*8来获取指向存储入口地址的地址，
// 通过*(%r10+%rbx*8)获取到入口地址，
// 然后跳转到入口地址执行
jmpq *(%r10,%rbx,8)

// 参数i就是opcode, _table为9x256的数组
void DispatchTable::set_entry(
		int i, EntryPoint& entry) {
		_table[btos][i] = entry.entry(btos);
		_table[ctos][i] = entry.entry(ctos);
		_table[stos][i] = entry.entry(stos);
		_table[atos][i] = entry.entry(atos);
		_table[itos][i] = entry.entry(itos);
		_table[ltos][i] = entry.entry(ltos);
		_table[ftos][i] = entry.entry(ftos);
		_table[dtos][i] = entry.entry(dtos);
		_table[vtos][i] = entry.entry(vtos);
}
_table的一维为栈顶缓存状态，二维为Opcode，通过这2个维度能够找到一段机器指令，这就是根据当前的栈顶缓存状态定位到的字节码需要执行的机器指令片段

第9篇-字节码指令的定义
Bytecodes::initialize()
def(_nop , "nop"                 , "b"    , NULL    , T_VOID , 0, false);
bytecode name就是字节码名称；
wide表示字节码前面是否可以加wild，如果可以，则值为"wbii"；
result tp表示指令执行后的结果类型，如为T_ILLEGAL时，表示只参考当前字节码无法决定执行结果的类型，如_invokevirtual方法调用指令，结果类型应该为方法返回类型，但是此时只参数这个调用方法的字节码指令是无法决定的；
stk表示对表达式栈深度的影响，如_nop指令不执行任何操作，所以对表达式栈的深度无影响，stk的值为0；当用_iconst_0向栈中压入0时，栈的深度增加1，所以stk的值为1。当为_lconst_0时，栈的深度会增加2；当为_lstore_0时，栈的深度会减少2；
traps表示can_trap，这个比较重要，在后面会详细介绍； ???
format，这个属性能表达2个意思，首先能表达字节码的格式，另外还能表示字节码的长度。
format详解:
b：表示字节码指令是非可变长度的，所以对于tableswitch、lookupswitch这种可变长度的指令来说，format字符串中不会含有b字符 
c：操作数为有符号的常量，如bipush指令将byte带符号扩展为一个int类型的值，然后将这个值入栈到操作数栈中 
i：操作数为无符号的本地变量表索引值，如iload指令从局部变量表加载一个int类型的值到操作数栈中 
j：操作数为常量池缓存的索引，注意常量池缓存索引不同与常量池索引，关于常量池索引，在《深入剖析Java虚拟机：源码剖析与实例详解》基础卷中详细介绍过，这里不再介绍 
k：操作数为无符号的常量池索引，如ldc指令将从运行时常量池中提取数据并压入操作数栈，所以格式为"bk" 
o：操作数为分支偏移，如ifeq表示整数与零比较，如果整数为0，则比较结果为真，将操作数看为分支偏移量进行跳转，所以格式为”boo“ 
_：可直接忽略
w：可用来扩展局部变量表索引的字节码，这些字节码有iload、fload等，所以wild的值为"wbii" 

第10篇-初始化模板表
void TemplateInterpreter::initialize() {
 	if 	(_code != NULL) 
		return;
 	 	
 	// 抽象解释器AbstractInterpreter的初始化，
 	// AbstractInterpreter是基于汇编模型的解释器的共同基类，
 	// 定义了解释器和解释器生成器的抽象接口
 	AbstractInterpreter::initialize(); ???
 	 	
 	// 模板表TemplateTable的初始化，模板表TemplateTable保存了各个字节码的模板
 	TemplateTable::initialize();
 	 	
 	// generate interpreter
 	{
 	 	ResourceMark rm;
 	 	int 	code_size = InterpreterCodeSize;
 	 	// CodeCache的Stub队列StubQueue的初始化
 	 	_code = new 	StubQueue(new 	InterpreterCodeletInterface, code_size, NULL,"Interpreter");
 	 	// 实例化模板解释器生成器对象TemplateInterpreterGenerator
 	 	InterpreterGenerator g(_code);
 	}
 	 	
 	// 初始化字节分发表
 	_active_table = _normal_table;
}
TemplateTable::initialize()
def(Bytecodes::_invokevirtual, ubcp|disp|clvm|____, vtos, vtos, invokevirtual, f2_byte);
标志位ubcp|disp|clvm|iswd详解:
uses_bcp_bit，标志需要使用字节码指针。表示生成的模板代码中是否需要使用指向字节码指令的指针，其实也就是说是否需要读取字节码指令的操作数，所以含有操作数的指令大部分都需要bcp，但是有一些是不需要的，如monitorenter与monitorexit等，这些的操作数都在表达式栈中，表达式栈顶就是其操作数，并不需要从Class文件中读取，所以不需要bcp；
does_dispatch_bit，标志表示自己是否含有控制流转发逻辑，如tableswitch、lookupswitch、invokevirtual、ireturn等字节码指令，本身就需要进行控制流转发；
calls_vm_bit，标志是否需要调用JVM函数，在调用TemplateTable::call_VM()函数时都会判断是否有这个标志，通常方法调用JVM函数时都会通过调用TemplateTable::call_VM()函数来间接完成调用。JVM函数就是用C++写的函数；
wide_bit，标志是否是wide指令（使用附加字节扩展全局变量索引）
_tos_in与_tos_out：
表示模板执行前与模板执行后的TosState(TopOfStack state: 栈顶的数据类型)
如iload指令，执行之前栈顶状态为vtos，表示并不会使用栈顶的数据，所以如果程序为了提高执行效率将上一次执行的结果缓存到了寄存器中，那么此时就应该在执行iload指令之前将这个寄存器的值压入栈顶。iload指令执行之后的栈顶状态为itos，因为iload是向操作数栈中压入一个整数，所以此时的栈顶状态为int类型，那么这个值可以缓存到寄存器中，假设下一个指令为ireturn，那么栈顶之前与之后的状态分别为itos和itos，那么可直接将缓存在寄存器中的int类型返回即可，不需要做任何和操作数栈相关的操作。

第11篇-初始化StubQueue
StubQueue是用来保存生成的本地代码的Stub队列，队列每一个元素对应一个InterpreterCodelet对象，InterpreterCodelet对象继承自抽象基类Stub，包含了字节码对应的本地代码以及一些调试和输出信息。
每个字节码都有一个InterpreterCodelet实例，所以在解释执行时，则执行的就是由InterpreterCodelet实例代表的机器指令片段。

第12篇-认识CodeletMark
InterpreterCodelet依赖CodeletMark完成自动创建和初始化。CodeletMark继承自ResourceMark，允许自动析构，执行的主要操作就是，会按照InterpreterCodelet中存储的实际机器指令片段分配内存并提交。

第13篇-通过InterpreterCodelet存储机器指令片段
空

第14篇-生成重要的例程
error exits								当方法出现时会调用这个例程，进行出错时程序退出
bytecode tracing support				配置命令-XX:+TraceBytecodes后，进行字节码追踪
return entry points 					函数返回入口
invoke return entry points 				对于某些invoke字节码调用指令来说，需要一些特殊的返回入口
earlyret entry points 					VMTI的EarlyReturn入口
deoptimization entry points 	 		从"逆优化"调用返回的入口
result handlers for native calls 		本地方法调用返回值处理handlers
continuation entry points 				continuation入口
safepoint entry points 					safepoint入口，当执行字节码时，如果要求解释执行进入安全点，则会执行safepoint入口指定的机器指令片段
exception handling 						异常处理例程
throw exception entrypoints 			抛出异常的入口
all non-native method kinds 			非本地方法的入口
all native method kinds					本地方法的入口
Bytecodes 								字节码的入口

字节码入口:
TemplateInterpreterGenerator::generate_all()
TemplateInterpreterGenerator::set_entry_points_for_all_bytes
void TemplateInterpreterGenerator::set_short_entry_points(Template* t, address& bep, address& cep, address& sep, address& aep, address& iep, address& lep, address& fep, address& dep, address& vep) {
  assert(t->is_valid(), "template must exist");
  switch (t->tos_in()) {
    case btos:
    case ztos:
    case ctos:
    case stos:
      ShouldNotReachHere();  // btos/ctos/stos should use itos.
      break;
    //vep: void entry point(当tos为vtos时的入口,从栈顶pop到寄存器进行缓存以满足atos)
    //aep: object entry point(当tos为atos时的入口)
    case atos: vep = __ pc(); __ pop(atos); aep = __ pc(); generate_and_dispatch(t); break;
    case itos: vep = __ pc(); __ pop(itos); iep = __ pc(); generate_and_dispatch(t); break;
    case ltos: vep = __ pc(); __ pop(ltos); lep = __ pc(); generate_and_dispatch(t); break;
    case ftos: vep = __ pc(); __ pop(ftos); fep = __ pc(); generate_and_dispatch(t); break;
    case dtos: vep = __ pc(); __ pop(dtos); dep = __ pc(); generate_and_dispatch(t); break;
    case vtos: set_vtos_entry_points(t, bep, cep, sep, aep, iep, lep, fep, dep, vep);     break;
    default  : ShouldNotReachHere();                                                 break;
  }
}
void TemplateInterpreterGenerator::generate_and_dispatch(Template* t, TosState tos_out) {
 	// 生成当前字节码指令对应的机器指令片段
 	t->generate(_masm);

 	if 	(t->does_dispatch()) {
 	 	// asserts
 	} else 	{
 	 	// 生成分发到下一个字节码指令的逻辑 InterpreterMacroAssembler::dispatch_next
 	 	__ dispatch_epilog(tos_out, step);
 	}
}
上一个字节码指令的执行结果和下一个指令执行之前要求的栈顶缓存状态共同决定了指令的入口，也就是说一个指令其实有多个入口

15~18 跳过
第15章-解释器及解释器生成器
第16章-汇编器
第17章-x86-64寄存器
第18章-x86指令集之常用指令
第19篇-加载与存储指令（1）
字节码采用大端存储，所以需要通过bswap和位移计算变换为小端存储，参考sipush的汇编
第20篇-加载与存储指令之ldc与_fast_aldc指令
ldc指令可以加载String、方法类型或方法句柄的符号引用，但是如果要加载String、方法类型或方法句柄的符号引用，则会在类连接过程中重写ldc字节码指令为虚拟机内部使用的字节码指令_fast_aldc:
// TemplateTable::ldc(bool wide)
// ldc指定的格式为ldc index，index为一个字节
0x00007fffe1028530: movzbl 0x1(%r13),%ebx // 加载index到%ebx

// %rcx指向缓存池首地址、%rax指向类型数组_tags首地址
// 获取Method*
0x00007fffe1028535: mov -0x18(%rbp),%rcx
// 获取ConstMethod*
0x00007fffe1028539: mov 0x10(%rcx),%rcx
// 获取ConstantPool*
0x00007fffe102853d: mov 0x8(%rcx),%rcx
// 获取ConstantPool::_tags
0x00007fffe1028541: mov 0x10(%rcx),%rax

// 从_tags数组获取操作数类型并存储到%edx中
0x00007fffe1028545: movzbl 0x4(%rax,%rbx,1),%edx

// $0x64代表JVM_CONSTANT_UnresolvedClass，比较，如果类还没有链接，则直接跳转到call_ldc
0x00007fffe102854a: cmp $0x64,%edx
0x00007fffe102854d: je 0x00007fffe102855d   // call_ldc

// $0x67代表JVM_CONSTANT_UnresolvedClassInError，也就是如果类在链接过程中出现错误，则跳转到call_ldc
0x00007fffe102854f: cmp $0x67,%edx
0x00007fffe1028552: je 0x00007fffe102855d  // call_ldc

// $0x7代表JVM_CONSTANT_Class，表示如果类已经进行了连接，则跳转到notClass
0x00007fffe1028554: cmp $0x7,%edx
0x00007fffe1028557: jne 0x00007fffe10287c0 // notClass

// 调用TemplateTable::call_VM()函数
// 类在没有连接或连接过程中出错，则执行如下的汇编代码
// -- call_ldc --
// 将wide的值移到%esi寄存器，为后续
// 调用InterpreterRuntime::ldc(JavaThread* thread, bool wide)函数准备第2个参数
0x00007fffe102855d: mov $0x0,%esi
// 调用MacroAssembler::call_VM()函数，通过此函数来调用HotSpot VM中用
// C++编写的函数，通过这个C++编写的函数来调用InterpreterRuntime::ldc()函数
0x00007fffe1017542: callq 0x00007fffe101754c
0x00007fffe1017547: jmpq 0x00007fffe10287ba // 跳转到E1
// 调用MacroAssembler::call_VM_helper()函数
// 将栈顶存储的返回地址设置到%rax中，也就是将存储地址0x00007fffe1017547
// 的栈的slot地址设置到%rax中
0x00007fffe101754c: lea 0x8(%rsp),%rax

// 调用InterpreterMacroAssembler::call_VM_base()函数存储bcp到栈中特定位置
0x00007fffe1017551: mov %r13,-0x38(%rbp)

// 调用MacroAssembler::call_VM_base()函数
// 将r15中的值移动到rdi寄存器中，也就是为函数调用准备第一个参数
0x00007fffe1017555: mov %r15,%rdi
// 只有解释器才必须要设置fp
// 将last_java_fp保存到JavaThread类的last_java_fp属性中
0x00007fffe1017558: mov %rbp,0x200(%r15)
// 将last_java_sp保存到JavaThread类的last_java_sp属性中
0x00007fffe101755f: mov %rax,0x1f0(%r15)

// 调用MacroAssembler::call_VM_leaf_base()函数
// 检查对齐
// %esp对齐的操作，跳转到 L
0x00007fffe1017566: test $0xf,%esp
0x00007fffe101756c: je 0x00007fffe1017584
// %esp没有对齐时的操作
0x00007fffe1017572: sub $0x8,%rsp
// 调用函数，也就是调用InterpreterRuntime::ldc()函数
0x00007fffe1017576: callq 0x00007ffff66a22a2
0x00007fffe101757b: add $0x8,%rsp
// 跳转到E2
0x00007fffe101757f: jmpq 0x00007fffe1017589
// -- L --
// %esp对齐的操作
// 调用函数，也就是调用InterpreterRuntime::ldc()函数
0x00007fffe1017584: callq 0x00007ffff66a22a2

// 结束调用MacroAssembler::call_VM_leaf_base()函数

// -- E2 --
// 重置JavaThread::last_java_sp与JavaThread::last_java_fp属性的值
0x00007fffe1017589: movabs $0x0,%r10
0x00007fffe1017593: mov %r10,0x1f0(%r15)
0x00007fffe101759a: movabs $0x0,%r10
0x00007fffe10175a4: mov %r10,0x200(%r15)

// check for pending exceptions (java_thread is set upon return)
0x00007fffe10175ab: cmpq $0x0,0x8(%r15)
// 如果没有异常则直接跳转到ok
0x00007fffe10175b3: je 0x00007fffe10175be
// 如果有异常则跳转到StubRoutines::forward_exception_entry()获取的例程入口
0x00007fffe10175b9: jmpq 0x00007fffe1000420

// -- ok --
// 将JavaThread::vm_result属性中的值存储到%rax寄存器中并清空vm_result属性的值
0x00007fffe10175be: mov 0x250(%r15),%rax
0x00007fffe10175c5: movabs $0x0,%r10
0x00007fffe10175cf: mov %r10,0x250(%r15)

// 结束调用MacroAssembler::call_VM_base()函数

// 恢复bcp与locals
0x00007fffe10175d6: mov -0x38(%rbp),%r13
0x00007fffe10175da: mov -0x30(%rbp),%r14

// 结束调用MacroAssembler::call_VM_helper()函数

0x00007fffe10175de: retq
// 结束调用MacroAssembler::call_VM()函数

整体调用栈:
TemplateTable::call_VM()
MacroAssembler::call_VM()
    MacroAssembler::call_VM_helper()
       InterpreterMacroAssembler::call_VM_base()
           MacroAssembler::call_VM_base()
                MacroAssembler::call_VM_leaf_base()
最重要的就是在MacroAssembler::call_VM_base()函数中保存rsp、rbp的值到JavaThread::last_java_sp与JavaThread::last_java_fp属性中(避免rsp和rbp被破坏，同理r13和r14也被保护起来)，
然后通过MacroAssembler::call_VM_leaf_base()函数生成的汇编代码来调用C++编写的InterpreterRuntime::ldc()函数

// -- E1 --
0x00007fffe10287ba: push %rax // 将调用的结果存储到表达式中
0x00007fffe10287bb: jmpq 0x00007fffe102885e // 跳转到Done

// -- notClass --
// $0x4表示JVM_CONSTANT_Float
0x00007fffe10287c0: cmp $0x4,%edx
0x00007fffe10287c3: jne 0x00007fffe10287d9 // 跳到notFloat
// 当ldc字节码指令加载的数为float时执行如下汇编代码
0x00007fffe10287c5: vmovss 0x58(%rcx,%rbx,8),%xmm0
0x00007fffe10287cb: sub $0x8,%rsp
0x00007fffe10287cf: vmovss %xmm0,(%rsp)
0x00007fffe10287d4: jmpq 0x00007fffe102885e // 跳转到Done

// -- notFloat --
// 当ldc字节码指令加载的为非float，也就是int类型数据时通过push加入表达式栈
0x00007fffe1028859: mov 0x58(%rcx,%rbx,8),%eax
0x00007fffe102885d: push %rax

// TemplateTable::fast_aldc(bool wide)
0x00007fffe10243d0: movzbl 0x1(%r13),%edx

// 调用InterpreterMacroAssembler::load_resolved_reference_at_index()函数生成

// shl表示逻辑左移，相当于乘4,因为ConstantPoolCacheEntry的大小为4个字
0x00007fffe10243d5: shl $0x2,%edx

// 获取Method*
0x00007fffe10243d8: mov -0x18(%rbp),%rax
// 获取ConstMethod*
0x00007fffe10243dc: mov 0x10(%rax),%rax
// 获取ConstantPool*
0x00007fffe10243e0: mov 0x8(%rax),%rax
// 获取ConstantPool::_resolved_references属性的值，这个值是一个指向对象数组的指针
0x00007fffe10243e4: mov 0x30(%rax),%rax

// JNIHandles::resolve(obj)
0x00007fffe10243e8: mov (%rax),%rax

// 从_resolved_references数组指定的下标索引处获取oop，先进行索引偏移
0x00007fffe10243eb: add %rdx,%rax

// 要在%rax上加0x10，是因为数组对象的头大小为2个字，加上后%rax就指向了oop
0x00007fffe10243ee: mov 0x10(%rax),%eax

ConstantPool::_resolved_references的调用栈(自下而上):
ConstantPool::initialize_resolved_references()  constantPool.cpp     
Rewriter::make_constant_pool_cache()  rewriter.cpp  
Rewriter::Rewriter()  rewriter.cpp
Rewriter::rewrite()  rewriter.cpp
InstanceKlass::rewrite_class()  instanceKlass.cpp  
InstanceKlass::link_class_impl()  instanceKlass.cpp

// %eax中存储着表示目标的oop
0x00007fffe1024479: test %eax,%eax
// 如果已经获取到了oop，则跳转到resolved
0x00007fffe102447b: jne 0x00007fffe1024481

// 没有获取到oop，需要进行连接操作，0xe5是_fast_aldc的Opcode
0x00007fffe1024481: mov $0xe5,%edx

// 省略通过call_VM调用InterpreterRuntime::resolve_ldc() 进行解析

string类型常量的解析调用栈(自下而上):
ConstantPool::string_at_put()   constantPool.hpp
ConstantPool::string_at_impl()  constantPool.cpp
ConstantPool::resolve_constant_at_impl()     constantPool.cpp  
ConstantPool::resolve_cached_constant_at()   constantPool.hpp  
Bytecode_loadconstant::resolve_constant()    bytecode.cpp  
InterpreterRuntime::resolve_ldc()            interpreterRuntime.cpp

string_at_put会根据表示字符串的Symbol实例创建出表示字符串的oop, 然后存储到ConstantPool::_resolved_references属性中，
再次解析时会优先从_resolved_references属性中获取，保证字符串常量在jvm的唯一性

第21篇-加载与存储指令之iload、_fast_iload等
// TemplateTable::iload()
// 将%ebx指向下一条字节码指令的首地址
0x00007fffe1028d30: movzbl 0x2(%r13),%ebx
// $0x15为_iload指令的操作码值
0x00007fffe1028d35: cmp $0x15,%ebx
// 当下一条指令为iload时，直接跳转到done
0x00007fffe1028d38: je 0x00007fffe1028deb // done

// 0xdf为_fast_iload指令的操作码值
0x00007fffe1028d3e: cmp $0xdf,%ebx
// 将_fast_iload2指令移动到%ecx
0x00007fffe1028d44: mov $0xe0,%ecx
0x00007fffe1028d49: je 0x00007fffe1028d5a // rewrite

// 0x34为_caload指令的操作码
// _caload指令表示从数组中加载一个char类型数据到操作数栈
0x00007fffe1028d4b: cmp $0x34,%ebx
// 将_fast_icaload移动到%ecx中
0x00007fffe1028d4e: mov $0xe1,%ecx
0x00007fffe1028d53: je 0x00007fffe1028d5a // rewrite

// 将_fast_iload移动到%ecx中
0x00007fffe1028d55: mov $0xdf,%ecx

// -- rewrite --

// 调用patch_bytecode()函数
// 重写为fast版本，因为%cl中存储的是字节码的fast版本，%ecx的8位叫%cl
0x00007fffe1028de7: mov %cl,0x0(%r13)

// -- done --

// 获取字节码指令的操作数，这个操作数为本地变量表的索引
0x00007fffe1028deb: movzbl 0x1(%r13),%ebx
0x00007fffe1028df0: neg %rbx
// 通过本地变量表索引从本地变量表中加载值到%eax中，
// %eax中存储的就是栈顶缓存值，所以不需要压入栈内
0x00007fffe1028df3: mov (%r14,%rbx,8),%eax
 cur        next      rewrite
iload ->    iload
      ->    fast_iload   ->  fast_iload2
      ->    其他          ->  fast_iload

第22篇-字节码运算指令
空白
第23篇-字节码类型转换指令
空白
第24篇-对象操作指令之getstatic
ConstantPoolCacheEntry结构:
              8     8      16
_indices    [ b2 | b1 |  index  ] b2: put操作码  b1: get操作码  index: 原常量池索引
_f1         [   metadata ptr    ] 元数据拥有者 metadata ptr (method or klass)
_f2         [   offset          ] 字段偏移(在类定义中的偏移)、虚函数表中的索引编号、指向final方法的指针等
_flags      [tos|0|F=1|0|0|0|f|v|0 |0000|field_index] (for field entries) field_index 字段索引(在class文件中的slot值)
bit length  [ 4 |1| 1 |1|1|1|1|1|1 |-4--|--8--|--8--]
_flags      [tos|0|F=0|M|A|I|f|0|vf|0000|00000|psize] (for method entries) psize 参数的大小
flag说明: f: 1为final; v: 1为volatile; vf: virtual but final; I: 动态分派 tos栈顶缓存: 字段类型对应的TosState枚举值; 操作码Opcode: 标识是否resolved
参考ConstantPoolCacheEntry::set_field

void TemplateTable::getstatic(int byte_no) {
  getfield_or_static(byte_no, true); // getstatic的byte_no值为1
}
// TemplateTable::getfield_or_static()
// 获取ConstantPoolCache中ConstantPoolCacheEntry的index
0x00007fffe101fd10: movzwl 0x1(%r13),%edx
// 从栈中获取ConstantPoolCache的首地址
0x00007fffe101fd15: mov -0x28(%rbp),%rcx

// 左移2位是因为ConstantPoolCacheEntry的内存占用是4个指针大小
0x00007fffe101fd19: shl $0x2,%edx
// 获取ConstantPoolCacheEntry[_indices,_f1,_f2,_flags]中的_indices
// 因为ConstantPoolCache的大小为16字节，%rcx+0x10定位到第一个ConstantPoolCacheEntry的开始位置
// %rdx*8算出来的是相对于第一个ConstantPoolCacheEntry的字节偏移
0x00007fffe101fd1c: mov 0x10(%rcx,%rdx,8),%ebx
// _indices向右移动16位后获取get bytecode与put bytecode
0x00007fffe101fd20: shr $0x10,%ebx
// 获取get bytecode字段的值
0x00007fffe101fd23: and $0xff,%ebx
// 0xb2是getstatic指令的Opcode，比较值，如果相等就说明已经连接，跳转到resolved
0x00007fffe101fd29: cmp $0xb2,%ebx
0x00007fffe101fd2f: je 0x00007fffe101fdce

// 将getstatic字节码的Opcode存储到%ebx中
0x00007fffe101fd35: mov $0xb2,%ebx

// 省略通过调用MacroAssembler::call_VM()函数来执行InterpreterRuntime::resolve_get_put()函数的汇编代码
// InterpreterRuntime::resolve_get_put()函数会填充常量池缓存中ConstantPoolCacheEntry信息
// InterpreterRuntime::resolve_get_put调用get_index_u2_cpcache()函数从当前方法对应的栈帧中获取bcp，然后通过bcp来获取字节码指令的操作数，也就是常量池索引，
// 得到常量池索引后调用LinkResolver::resolve_field_access()函数可能会连接类和字段(调用resolve_klass()连接类，调用resolve_field()连接字段)，
// 然后将查询到的字段相关信息存储到fieldDescriptor中的fd字段，同时填充ConstantPoolCacheEntry信息

// 将ConstantPoolCacheEntry的索引存储么%edx
0x00007fffe101fdc2: movzwl 0x1(%r13),%edx
// 将ConstantPoolCache的首地址存储到%rcx
0x00007fffe101fdc7: mov -0x28(%rbp),%rcx
// 获取对应的ConstantPoolCacheEntry对应的索引
0x00007fffe101fdcb: shl $0x2,%edx

// --resolved --

// 获取[_indices,_f1,_f2,_flags]中的_f2，
// _f2中保存的是字段在java.lang.Class实例中的字节偏移，通过此偏移就可获取此字段存储在java.lang.Class实例的值
0x00007fffe101fdce: mov 0x20(%rcx,%rdx,8),%rbx
// 获取[_indices,_f1,_f2,_flags]中的_flags 
0x00007fffe101fdd3: mov 0x28(%rcx,%rdx,8),%eax
// 获取[_indices,_f1,_f2,_flags]中的_f1保存了字段拥有者，也就是java.lang.Class对象
0x00007fffe101fdd7: mov 0x18(%rcx,%rdx,8),%rcx

// 从_f1中获取_java_mirror属性的值
0x00007fffe101fddc: mov 0x70(%rcx),%rcx
// 将_flags向右移动28位，剩下TosState
0x00007fffe101fde0: shr $0x1c,%eax
0x00007fffe101fde3: and $0xf,%eax
// 如果不相等，说明TosState的值不为0，则跳转到notByte
0x00007fffe101fde6: jne 0x00007fffe101fdf6

// btos
// btos的编号为0,代码执行到这里时，可能栈顶缓存要求是btos
// %rcx中存储的是_java_mirror，%rbx中存储的是_f2，静态变量存储在_java_mirror中
0x00007fffe101fdec: movsbl (%rcx,%rbx,1),%eax
0x00007fffe101fdf0: push %rax
// 跳转到Done
0x00007fffe101fdf1: jmpq 0x00007fffe101ff0c

// -- notByte --
// %eax中存储的是TosState，如果不为atos，则跳转到notObj
0x00007fffe101fdf6: cmp $0x7,%eax
0x00007fffe101fdf9: jne 0x00007fffe101fe90

// 省略其他tos对应的汇编代码

// Done
0x00007fffe101ff0c: movzbl 0x3(%r13),%ebx
0x00007fffe101ff11: add    $0x3,%r13
0x00007fffe101ff15: movabs $0x10b873670,%r10
0x00007fffe101ff1f: jmpq   *(%r10,%rbx,8)

第25篇-对象操作指令之getfield
// TemplateTable::getfield_or_static()
// 省略前面汇编代码，参考getstatic
---- resolved ---- 
 
// 获取[_indices,_f1,_f2,_flags]中的_f2，_f2中保存的是字段在oop实例中的字节偏移，通过此偏移就可获取此字段存储在oop中的值
0x00007fffe102038e: mov 0x20(%rcx,%rdx,8),%rbx
 
// 获取[_indices,_f1,_f2,_flags]中的_flags 
0x00007fffe1020393: mov 0x28(%rcx,%rdx,8),%eax
 
// 将栈中的objectref对象弹出到%rcx中
0x00007fffe1020397: pop %rcx
 
// provoke OS NULL exception if reg = NULL by
// accessing M[reg] w/o changing any (non-CC) registers
// NOTE: cmpl is plenty here to provoke a segv
0x00007fffe1020398: cmp (%rcx),%rax
 
// 将_flags向右移动28位，剩下TosState
0x00007fffe102039b: shr $0x1c,%eax
0x00007fffe102039e: and $0xf,%eax
// 如果不相等，说明TosState的值不为0，则跳转到notByte
0x00007fffe10203a1: jne 0x00007fffe10203ba
 
// btos
 
// btos的编号为0,代码执行到这里时，可能栈顶缓存要求是btos
// %rcx中存储的是objectref，%rbx中存储的是_f2，获取字段对应的值存储到%rax中
0x00007fffe10203a7: movsbl (%rcx,%rbx,1),%eax
0x00007fffe10203ab: push %rax
 
// 对字节码指令进行重写，将Bytecodes::_fast_bgetfield的Opcode存储到%ecx中
0x00007fffe10203ac: mov $0xcc,%ecx
// 将Bytecodes::_fast_bgetfield的Opcode更新到字节码指令的操作码
0x00007fffe10203b1: mov %cl,0x0(%r13)
// 跳转到---- Done ----
0x00007fffe10203b5: jmpq 0x00007fffe102050f
---- notByte ----
0x00007fffe10203ba: cmp $0x7,%eax
0x00007fffe10203bd: jne 0x00007fffe102045d  // 跳转到notObj

// 省略其他tos对应的汇编代码

def(_fast_agetfield , "fast_agetfield"      , "bJJ"  , NULL    , T_OBJECT , 0, true , _getfield );
以_fast_agetfield内部定义的字节码指令为例为来，生成函数为TemplateTable::fast_accessfield()函数，汇编代码如下：
0x00007fffe101e4e1: movzwl 0x1(%r13),%ebx
0x00007fffe101e4e6: mov -0x28(%rbp),%rcx
0x00007fffe101e4ea: shl $0x2,%ebx
// 获取ConstantPoolCacheEntry[_indices,_f1,_f2,_flags]中的_f2
0x00007fffe101e4ed: mov 0x20(%rcx,%rbx,8),%rbx
 
// 检查空异常
0x00007fffe101e4f2: cmp (%rax),%rax
// %rax中存储的是objectref，也就是要从这个实例中获取字段的值，通过偏移%rbx后就
// 能获取到偏移的值，然后加载到%eax
0x00007fffe101e4f5: mov (%rax,%rbx,1),%eax

第26篇-对象操作指令之putstatic
void TemplateTable::putfield(int byte_no) {
  putfield_or_static(byte_no, false);
}
// TemplateTable::resolve_cache_and_index()
// 省略前面汇编代码，参考getstatic
// ---- resolved ----
 
// 执行如下代码时，表示字段已经连接完成
0x00007fffe102004e: mov 0x20(%rcx,%rdx,8),%rbx
0x00007fffe1020053: mov 0x28(%rcx,%rdx,8),%eax
0x00007fffe1020057: mov 0x18(%rcx,%rdx,8),%rcx
0x00007fffe102005c: mov 0x70(%rcx),%rcx
0x00007fffe1020060: mov %eax,%edx
// 将_flags向右移动21位，判断是否有volatile关键字
0x00007fffe1020062: shr $0x15,%edx
0x00007fffe1020065: and $0x1,%edx
// 将_flags向右移动28位，剩下TosState
0x00007fffe1020068: shr $0x1c,%eax
 
// 如果不为btos，则跳转到notByte
0x00007fffe102006b: and $0xf,%eax
0x00007fffe102006e: jne 0x00007fffe1020083
 
// btos
 
// 将栈顶的值存储到%eax中，这个值会写入到对应的字段中
0x00007fffe1020074: mov (%rsp),%eax
0x00007fffe1020077: add $0x8,%rsp
// %rcx为_java_mirror，%rbx为_f2，表示域在类中的偏移
0x00007fffe102007b: mov %al,(%rcx,%rbx,1)
0x00007fffe102007e: jmpq 0x00007fffe10201be // 跳转到Done
// -- notByte --
// 如果不为atos，则跳转到notObj
0x00007fffe1020083: cmp $0x7,%eax
0x00007fffe1020086: jne 0x00007fffe1020130

// atos
// 将栈顶的值弹出到%rax中，这个值将用来更新对应字段的值
0x00007fffe102008c: pop %rax
// ...
// 将值更新到对应的字段上
0x00007fffe1020115: mov %eax,(%rcx,%rbx,1)
// 其中的0x9是CardTableModRefBS::card_shift，shr表示逻辑右移，由于%rcx指向的是
// java.lang.Class实例的首地址，向右移后%rcx就算出了卡表的索引
0x00007fffe1020118: shr $0x9,%rcx
// 地址常量$0x7fffe07ff000表示卡表的基地址
0x00007fffe102011c: movabs $0x7fffe07ff000,%r10
// 将对应的卡表项标记为脏，其中常量0x0就表示是脏卡
0x00007fffe1020126: movb $0x0,(%r10,%rcx,1)
0x00007fffe102012b: jmpq 0x00007fffe10201be // 跳转到Done

// 省略其他tos对应的汇编代码

// ---- Done ----

0x00007fffe10201be: test %edx,%edx
0x00007fffe10201c0: je 0x00007fffe10201cb
0x00007fffe10201c6: lock addl $0x0,(%rsp)

// ---- notVolatile ----
需要注意两点:
（1）更新引用字段时，通过屏障将对应的卡表项标记为脏，这样可在GC过程中扫描脏卡就可将活跃对象标记出来而不会造成遗漏；
（2）当字段有volatile关键字修饰时，需要填写lock指令前缀;
    Intel手册对 lock 前缀的说明如下：
        确保被修饰指令执行的原子性；(锁定特定内存地址,阻止其他的系统总线读取或修改这个内存地址)
        禁止该指令与前面和后面的读写指令重排序；
        指令执行完后把写缓冲区的所有数据刷新到内存中（这样这个指令之前的其他修改对所有处理器可见）

第27篇-操作数栈管理指令
空白
第28篇-控制转移指令
TemplateTable::_goto()
// -XX:-ProfileInterpreter可排除生成一些不必要的统计指令
goto生成的指令其实很多，因为goto指令是一个分支指令，其中会做一些性能统计以辅助进行编译优化，而且goto如果是在循环中的话，还可能会涉及到栈上替换的技术

第29篇-调用Java主类的main()方法
JavaMain()
    LoadMainClass()
    GetStaticMethodlD()
    CallStaticVoidMethod()

第30篇-解释执行main()方法小实例
空白
第31篇-方法调用指令之invokevirtual
// TemplateTable::invokevirtual()
// prepare_invoke 省略检查是否resolved，通过call_VM调用InterpreterRuntime::resolve_invoke()进行解析

// **** resolved ****

// ConstantPoolCacheEntry::_f2存储到%rbx
0x00007fffe1022052: mov 0x20(%rcx,%rdx,8),%rbx 
 // ConstantPoolCacheEntry::_flags存储到%edx
0x00007fffe1022057: mov 0x28(%rcx,%rdx,8),%edx 
 // 将flags移动到ecx中
0x00007fffe102205b: mov %edx,%ecx 
// 从flags中取出参数大小 
0x00007fffe102205d: and $0xff,%ecx 

// 获取到recv,%rcx中保存的是参数大小，最终计算参数所需要的大小为%rsp+%rcx*8-0x8，
// flags中的参数大小对实例方法来说，已经包括了recv的大小
// 如调用实例方法的第一个参数是this(recv)
0x00007fffe1022063: mov -0x8(%rsp,%rcx,8),%rcx // recv保存到%rcx 

// 将flags存储到r13中
0x00007fffe1022068: mov %edx,%r13d 
// 从flags中获取return type，也就是从_flags的高4位保存的TosState
0x00007fffe102206b: shr $0x1c,%edx 

// 将TemplateInterpreter::invoke_return_entry地址存储到%r10
0x00007fffe102206e: movabs $0x7ffff73b6380,%r10 
// %rdx保存的是return type，计算返回时例程的入口地址
// 因为TemplateInterpreter::invoke_return_entry是数组，保存了一组函数调用后返回时的例程的入口
0x00007fffe1022078: mov (%r10,%rdx,8),%rdx 
// 向栈中压入返回地址
0x00007fffe102207c: push %rdx 

// 还原ConstantPoolCacheEntry::_flags 
0x00007fffe102207d: mov %r13d,%edx 
// 还原bcp
0x00007fffe1022080: mov -0x38(%rbp),%r13

// invokevirtual_helper 调用java函数的例程

// 对于final方法来说，没有动态分派，所以不需要通过vtable进行目标查找
// flags存储到%eax
0x00007fffe1022084: mov %edx,%eax
// 测试调用的方法是否为final
0x00007fffe1022086: and $0x100000,%eax
// 如果不为final就直接跳转到----notFinal----
0x00007fffe102208c: je 0x00007fffe10220c0

// 通过(%rcx)来获取receiver的值，如果%rcx为空，则会引起OS异常
0x00007fffe1022092: cmp (%rcx),%rax

// 省略统计相关代码部分

// 设置调用者栈顶并保存
0x00007fffe10220b4: lea 0x8(%rsp),%r13
0x00007fffe10220b9: mov %r13,-0x10(%rbp)

// 跳转到Method::_from_interpretered_entry入口去执行
0x00007fffe10220bd: jmpq *0x58(%rbx)

// **** notFinal ****

// 对于非final方法来说，通过vtable查找动态分派需要调用的方法入口
// invokevirtual指令调用的如果是非final方法，直接跳转到这里
// %rcx中存储的是receiver，用oop来表示。通过oop获取Klass
0x00007fffe10220c0: mov 0x8(%rcx),%eax

// 调用MacroAssembler::decode_klass__not_null()函数生成下面的一个汇编代码
0x00007fffe10220c3: shl $0x3,%rax // LogKlassAlignmentInBytes=0x03

// 省略统计相关代码部分

// 以下汇编代码通过lookup_virtual_method()函数生成，将vtable_entry_addr加载到%rbx中
// %rax中存储的是recv_klass
// %rbx中存储的是vtable_index，
// 而0x1b8为InstanceKlass::vtable_start_offset()*wordSize+vtableEntry::method_offset_in_bytes()，
// 其实就是通过动态分派找到需要调用的Method*并存储到%rbx中
0x00007fffe1022169: mov 0x1b8(%rax,%rbx,8),%rbx

// 设置调用者的栈顶地址并保存
0x00007fffe1022171: lea 0x8(%rsp),%r13
0x00007fffe1022176: mov %r13,-0x10(%rbp)

// 跳转到Method::_from_interpreted_entry处执行
0x00007fffe102217a: jmpq *0x58(%rbx)

第32篇-解析interfacevirtual字节码指令
// InterpreterRuntime::resolve_invoke()
if (bytecode == Bytecodes::_invokevirtual || bytecode == Bytecodes::_invokeinterface) {
    ResourceMark rm(thread);
    // 调用method()函数从当前的栈帧中获取到需要执行的方法
    Method* m1 = method(thread);
    methodHandle m (thread, m1);
 
    // 调用bci()函数从当前的栈帧中获取需要执行的方法的字节码索引
    int i1 = bci(thread);
    Bytecode_invoke call(m, i1);
 
    // 当前需要执行的方法的签名
    Symbol* signature = call.signature();
 
    frame fm = thread->last_frame();
    oop x = fm.interpreter_callee_receiver(signature);
    receiver = Handle(thread,x);
}
//根据存储在当前栈中的bcp来获取字节码指令的操作数(常量池缓存项索引),然后调用LinkResolver::resolve_invoke()函数进行方法连接。
{
    JvmtiHideSingleStepping jhss(thread);
    int cpcacheindex = get_index_u2_cpcache(thread, bytecode);
    LinkResolver::resolve_invoke(info, receiver, pool,cpcacheindex, bytecode, CHECK);
    ...
}
// 然后会间接调用LinkResolver::resolve_invokevirtual()函数，其中会调用resolve_pool()和resolve_vritual_call()函数分别连接常量池和方法调用指令。
{
 
  KlassHandle resolved_klass;
  Symbol* method_name = NULL;
  Symbol* method_signature = NULL;
  KlassHandle current_klass;

  resolve_pool(resolved_klass, method_name, method_signature, current_klass, pool, index, CHECK);
  KlassHandle recvrKlass(THREAD, recv.is_null() ? (Klass*)NULL : recv->klass());
  resolve_virtual_call(result, recv, recvrKlass, resolved_klass, method_name, method_signature, current_klass, true, true, CHECK);
}
// resolve_pool()调用栈，最终调用resolve_or_fail()函数进行class解析
LinkResolver::resolve_pool()
LinkResolver::resolve_klass()
ConstantPool::klass_ref_at()
ConstantPool::klass_at()
ConstantPool::klass_at_impl()
SystemDictionary::resolve_or_fail()

// resolve_virtual_call()调用栈，先通过方法名和签名在resolve_method()中查找对应的方法，再在runtime_resolve_virtual_method中进行解析映射
LinkResolver::resolve_virtual_call()
LinkResolver::linktime_resolve_virtual_method()
    LinkResolver::resolve_method()
        LinkResolver::lookup_method_in_klasses()
        LinkResolver::lookup_method_in_interfaces()
LinkResolver::runtime_resolve_virtual_method()
    LinkResolver::vtable_index_of_interface_method()
    InstanceKlass::method_at_vtable()

void LinkResolver::runtime_resolve_virtual_method(
 CallInfo& result,
 methodHandle resolved_method,
 KlassHandle resolved_klass,
 Handle recv,
 KlassHandle recv_klass,
 bool check_null_and_abstract,
 TRAPS
) {
 
  int vtable_index = Method::invalid_vtable_index;
  methodHandle selected_method;
 
  // 当方法定义在接口中时，表示是miranda方法
  if (resolved_method->method_holder()->is_interface()) { 
    vtable_index = vtable_index_of_interface_method(resolved_klass,resolved_method);
 
    InstanceKlass* inst = InstanceKlass::cast(recv_klass());
    selected_method = methodHandle(THREAD, inst->method_at_vtable(vtable_index));
  } else {
    // 如果走如下的代码逻辑，则表示resolved_method不是miranda方法，需要动态分派且肯定有正确的vtable索引
    vtable_index = resolved_method->vtable_index();
 
    // 有些方法虽然看起来需要动态分派，但是如果这个方法有final关键字时，可进行静态绑定，所以直接调用即可
    // final方法其实不会放到vtable中，除非final方法覆写了父类中的方法
    if (vtable_index == Method::nonvirtual_vtable_index) {
      selected_method = resolved_method;
    } else {
      // 根据vtable和vtable_index以及inst进行方法的动态分派
      InstanceKlass* inst = (InstanceKlass*)recv_klass();
      selected_method = methodHandle(THREAD, inst->method_at_vtable(vtable_index));
    }
  } 
  
  // 函数将查找到调用时需要的所有信息存储到CallInfo类型的result变量中, 后续就可以根据info中相关信息填充到ConstantPoolCacheEntry
  result.set_virtual(resolved_klass, recv_klass, resolved_method, selected_method, vtable_index, CHECK);
}
void ConstantPoolCacheEntry::set_direct_or_vtable_call(
 Bytecodes::Code invoke_code,
 methodHandle method,
 int vtable_index
) {
    // ...
    // 可以看到，通过_invokevirtual指令时，并不一定都是动态分发，也有可能是静态绑定
    case Bytecodes::_invokevirtual:
      {
        if (!is_vtable_call) {
          assert(method->can_be_statically_bound(), "");
          // set_f2_as_vfinal_method checks if is_vfinal flag is true.
          set_method_flags(as_TosState(method->result_type()),
                           ( 1      << is_vfinal_shift) |
                           ((method->is_final_method() ? 1 : 0) << is_final_shift) |
                           ((change_to_virtual ? 1 : 0) << is_forced_virtual_shift), // 在接口中调用Object中定义的方法
                           method()->size_of_parameters());
          set_f2_as_vfinal_method(method());
        } else {
          // 执行这里的逻辑时，表示方法是非静态绑定的非final方法，需要动态分派，则vtable_index的值肯定大于等于0
          set_method_flags(as_TosState(method->result_type()),
                           ((change_to_virtual ? 1 : 0) << is_forced_virtual_shift),
                           method()->size_of_parameters());
          // 对于动态分发来说，ConstantPoolCacheEntry::_f2中保存的是vtable_index
          set_f2(vtable_index);
        }
        byte_no = 2;
        break;
      }
}

第33篇-方法调用指令之invokeinterface
// TemplateTable::invokeinterface

// 省略prepare_invoke的汇编代码

// 将ConstantPoolCacheEntry::_flags的值存储到%r14d中
0x00007fffe1022709: mov %edx,%r14d
// 检测一下_flags中是否含有is_forced_virtual_shift标识，如果有，
// 表示调用的是Object类中的方法，需要通过vtable进行动态分派
0x00007fffe102270c: and $0x800000,%r14d
0x00007fffe1022713: je 0x00007fffe1022812 // 跳转到----notMethod----

// 省略invoke virtual的汇编代码

// **** notMethod ****
 
// 让%r14指向本地变量表
0x00007fffe1022812: mov -0x30(%rbp),%r14 
// %rcx中存储的是receiver，%edx中保存的是Klass
0x00007fffe1022816: mov 0x8(%rcx),%edx 
// LogKlassAlignmentInBytes=0x03，进行对齐处理
0x00007fffe1022819: shl $0x3,%rdx
 
// 如下代码是调用如下函数生成的：
__ lookup_interface_method(rdx, // inputs: rec. class
rax, // inputs: interface
rbx, // inputs: itable index
rbx, // outputs: method
r13, // outputs: scan temp. reg
no_such_interface);
 
  
// 获取vtable的起始地址 
// %rdx中存储的是recv.Klass，获取Klass中
// vtable_length属性的值
0x00007fffe10228c1: mov 0x118(%rdx),%r13d 
 
// %rdx：recv.Klass，%r13为vtable_length，
// 最后r13指向第一个itableOffsetEntry
// 加一个常量0x1b8是因为vtable之前是InstanceKlass，也就是vtable首地址的offset
0x00007fffe10228c8: lea 0x1b8(%rdx,%r13,8),%r13 
0x00007fffe10228d0: lea (%rdx,%rbx,8),%rdx 
 
// 获取itableOffsetEntry::_interface并与%rax比较，%rax中存储的是要查找的接口
0x00007fffe10228d4: mov 0x0(%r13),%rbx
0x00007fffe10228d8: cmp %rbx,%rax
// 如果相等，则直接跳转到---- found_method ----
0x00007fffe10228db: je 0x00007fffe10228f3
 
// **** search ****
// 检测%rbx中的值是否为NULL，如果为NULL，
// 那就说明receiver没有实现要查询的接口，itableOffsetEntry的尾节点是NULL
0x00007fffe10228dd: test %rbx,%rbx
// 跳转到---- L_no_such_interface ----
0x00007fffe10228e0: je 0x00007fffe1022a8c
0x00007fffe10228e6: add $0x10,%r13
 
0x00007fffe10228ea: mov 0x0(%r13),%rbx
0x00007fffe10228ee: cmp %rbx,%rax
// 如果还是没有在itableOffsetEntry中找到接口类，
// 则跳转到search继续进行查找
0x00007fffe10228f1: jne 0x00007fffe10228dd // 跳转到---- search ----
 
// **** found_method ****
 
// 已经找到匹配接口的itableOffsetEntry，获取
// itableOffsetEntry的offset属性并存储到%r13d中
0x00007fffe10228f3: mov 0x8(%r13),%r13d
// 通过recv_klass进行偏移后找到itableMethodEntry
0x00007fffe10228f7: mov (%rdx,%r13,1),%rbx

最终itableMethodEntry的定位依赖以下两个汇编:
lea  (%rdx,%rbx,8),%rdx
...
mov  (%rdx,%r13,1),%rbx
itableMethodEntry的地址 = recv_klass首地址 + 8 * index + itableOffset * 1
itableMethodEntry数组的首地址 = recv_klass首地址 + itableOffset

0x00007fffe10228fb: test %rbx,%rbx
// 如果本来应该存储Method*的%rbx是空，则表示没有找到
// 这个方法，跳转到---- no_such_method ----
0x00007fffe10228fe: je 0x00007fffe1022987 
 
// 保存调用者的栈顶指针
0x00007fffe1022904: lea 0x8(%rsp),%r13 
0x00007fffe1022909: mov %r13,-0x10(%rbp)
// 跳转到Method::from_interpreted指向的例程并执行
0x00007fffe102290d: jmpq *0x58(%rbx) 
 
 
// 省略should_not_reach_here()函数生成的汇编
 
 
// **** no_such_method ****
// 当没有找到方法时，会跳转到这里执行
 
// 弹出调用prepare_invoke()函数压入的返回地址
0x00007fffe1022987: pop %rbx
// 恢复让%r13指向bcp
0x00007fffe1022988: mov -0x38(%rbp),%r13
// 恢复让%r14指向本地变量表
0x00007fffe102298c: mov -0x30(%rbp),%r14
 
 
// ... 省略通过call_VM()函数生成的汇编来调用InterpreterRuntime::throw_abstractMethodError()函数
// ... 省略调用should_not_reach_here()函数生成的汇编代码
 
// **** no_such_interface ****
 
// 当没有找到匹配的接口时执行的汇编代码
0x00007fffe1022a8c: pop %rbx
0x00007fffe1022a8d: mov -0x38(%rbp),%r13
0x00007fffe1022a91: mov -0x30(%rbp),%r14
 
// ... 省略通过call_VM()函数生成的汇编代码来调用InterpreterRuntime::throw_IncompatibleClassChangeError()函数
// ... 省略调用should_not_reach_here()函数生成的汇编代码

第34篇-解析invokeinterface字节码指令
LinkResolver::resolve_interface_call()
LinkResolver::linktime_resolve_interface_method()
    LinkResolver::resolve_interface_method()
        LinkResolver::lookup_method_in_klasses()
        LinkResolver::lookup_method_in_interfaces()
LinkResolver::runtime_resolve_interface_method()
    LinkResolver::lookup_instance_method_in_klasses()

第35篇-方法调用指令之invokespecial与invokestatic
空白

第36篇-方法返回指令之return
def(Bytecodes::_areturn , ____|disp|clvm|____, atos, atos, _return , atos );
def(Bytecodes::_return , ____|disp|clvm|____, vtos, vtos, _return , vtos);
def(Bytecodes::_return_register_finalizer , ____|disp|clvm|____, vtos, vtos, _return , vtos);
执行释放锁和退出当前栈帧的操作，生成函数都为TemplateTable::_return()。但是如果是Object对象的构造方法中的return指令，那么这个指令还可能会被重写为_return_register_finalizer指令

// TemplateTable::_return()
// 将JavaThread::do_not_unlock_if_synchronized属性存储到%dl中
0x00007fffe101b770: mov 0x2ad(%r15),%dl
// 重置JavaThread::do_not_unlock_if_synchronized属性值为false
0x00007fffe101b777: movb $0x0,0x2ad(%r15)

// 将Method*加载到%rbx中
0x00007fffe101b77f: mov -0x18(%rbp),%rbx
// 将Method::_access_flags加载到%ecx中
0x00007fffe101b783: mov 0x28(%rbx),%ecx
// 检查Method::flags是否包含JVM_ACC_SYNCHRONIZED
0x00007fffe101b786: test $0x20,%ecx
// 如果方法不是同步方法，跳转到----unlocked----
0x00007fffe101b78c: je 0x00007fffe101b970


// 如果在%dl寄存器中存储的_do_not_unlock_if_synchronized的值不为0，
// 则跳转到no_unlock，表示不要释放和锁相关的资源
0x00007fffe101b792: test $0xff,%dl
0x00007fffe101b795: jne 0x00007fffe101ba90 // 跳转到----no_unlock----处

// 在JavaThread类中定义了一个属性_do_not_unlock_if_synchronized，这个值表示在抛出异常的情况下不要释放receiver，此值仅在解释执行的情况下才会起作用

// 将之前字节码指令执行的结果存储到表达式栈顶，
// 由于return不需要返回执行结果，所以不需要设置返回值等信息，
// 最终在这里没有生成任何push指令

// 将BasicObjectLock存储到%rsi中，由于%rsi在调用C++函数时可做为
// 第2个参数传递，所以如果要调用unlock_object就可以传递此值
0x00007fffe101b79b: lea -0x50(%rbp),%rsi

// 获取BasicObjectLock::obj属性地址存储到%rax中
0x00007fffe101b79f: mov 0x8(%rsi),%rax

// 如果不为0，则跳转到unlock处，因为不为0，表示
// 这个obj有指向的锁对象，需要进行释放锁的操作
0x00007fffe101b7a3: test %rax,%rax
0x00007fffe101b7a6: jne 0x00007fffe101b8a8 // 跳转到----unlock----处

// 如果是其它的return指令，则由于之前通过push指令将结果保存在
// 表达式栈上，所以现在可通过pop将表达式栈上的结果弹出到对应寄存器中

-0x50(%rbp)指向了第1个BasicObjectLock对象，其中的sizeof(BasicObjectLock)的值为16，
BasicObjectLock中有2个属性，_lock(-0x50(%rbp))和_obj(-0x48(%rbp))，分别占用8字节。

// ----unlock----

// ============调用InterpreterMacroAssembler::unlock_object()函数生成如下的汇编代码==================

// 将%r13存储到栈中，防止异常破坏了%r13寄存器中的值
0x00007fffe101b8a8: mov %r13,-0x38(%rbp)

// 将BasicObjectLock::_lock的地址存储到%rax寄存器中
0x00007fffe101b8ac: lea (%rsi),%rax
// 将BasicObjectLock::_obj存储到%rcx寄存器中
0x00007fffe101b8af: mov 0x8(%rsi),%rcx

// 将BasicObjectLock::_obj的值设置为NULL，表示释放锁操作
0x00007fffe101b8b3: movq $0x0,0x8(%rsi)

// ----------当UseBiasedLocking的值为true时，调用MacroAssembler::biased_locking_exit()生成如下的汇编代码------------
// 从BasicObjectLock::_obj对象中取出mark属性值并相与
0x00007fffe101b8bb: mov (%rcx),%rdx
0x00007fffe101b8be: and $0x7,%rdx
// 如果BasicObjectLock::_obj指向的oop的mark属性后3位是偏向锁的状态，则跳转到---- done ----
0x00007fffe101b8c2: cmp $0x5,%rdx
0x00007fffe101b8c6: je 0x00007fffe101b96c
// ------------------------结束调用MacroAssembler::biased_locking_exit()生成的汇编代码---------------------

// 将BasicObjectLock::_lock这个oop对象的_displaced_header属性值取出
0x00007fffe101b8cc: mov (%rax),%rdx
// 判断一下是否为锁的重入，如果是锁的重入，则跳转到---- done ----
0x00007fffe101b8cf: test %rdx,%rdx
0x00007fffe101b8d2: je 0x00007fffe101b96c

// 让BasicObjectLock::_obj的那个oop的mark恢复为
// BasicObjectLock::_lock中保存的原对象头
0x00007fffe101b8d8: lock cmpxchg %rdx,(%rcx)
// 如果为0，则表示锁的重入，跳转到---- done ---- ????
0x00007fffe101b8dd: je 0x00007fffe101b96c

// 让BasicObjectLock::_obj指向oop，这个oop的对象头已经替换为了BasicObjectLock::_lock中保存的对象头
0x00007fffe101b8e3: mov %rcx,0x8(%rsi)

// -----------省略调用call_VM()函数生成汇编代码来执行C++函数InterpreterRuntime::monitorexit()----------------

// ---- done ----

0x00007fffe101b96c: mov -0x38(%rbp),%r13
0x00007fffe101b970: mov -0x40(%rbp),%rsi

// ==========结束调用InterpreterMacroAssembler::unlock_object()函数生成如下的汇编代码============

// 如果是其它的return指令，则由于之前通过push指令将结果保存在
// 表达式栈上，所以现在可通过pop将表达式栈上的结果弹出到对应寄存器中


// ----unlocked----
// 在执行这里的代码时，表示当前的栈中没有相关的锁，也就是
// 相关的锁对象已经全部释放

// ----restart----
// 检查一下，是否所有的锁都已经释放了

// %rsi指向当前栈中最靠栈顶的BasicObjectLock
0x00007fffe101b970: mov -0x40(%rbp),%rsi
// %rbx指向当前栈中最靠栈底的BasicObjectLock
0x00007fffe101b974: lea -0x40(%rbp),%rbx

// 跳转到----entry----
0x00007fffe101b978: jmpq 0x00007fffe101ba8b

// ----exception----
// Entry already locked, need to throw exception

// 当throw_monitor_exception的值为true时，执行如下2个函数生成的汇编代码：
// 执行call_VM()函数生成的汇编代码，就是调用C++函数InterpreterRuntime::throw_illegal_monitor_state_exception()
// 执行should_not_reach_here()函数生成的汇编代码

// 当throw_monitor_exception的值为false，执行如下汇编：
// 执行调用InterpreterMacroAssembler::unlock_object()函数生成的汇编代码
// install_monitor_exception的值为true时，执行call_VM()函数生成的汇编代码，就是调用C++函数InterpreterRuntime::new_illegal_monitor_state_exception()
// 无条件跳转到----restart ----

// ----loop----

// 将BasicObjectLock::obj与NULL比较，如果不相等，则跳转到----exception----
0x00007fffe101ba79: cmpq $0x0,0x8(%rsi)
0x00007fffe101ba81: jne 0x00007fffe101b97d // 则跳转到----exception----

// 0x10为BasicObjectLock，找到下一个BasicObjectLock
0x00007fffe101ba87: add $0x10,%rsi

// ----entry----
// 检查是否到达了锁对象存储区域的底部
0x00007fffe101ba8b: cmp %rbx,%rsi
// 如果不相等，跳转到loop
0x00007fffe101ba8e: jne 0x00007fffe101ba79 // 跳转到----loop----

// ----no_unlock----

// 省略jvmti support

// 将-0x8(%rbp)处保存的old stack pointer(saved rsp)取出来放到%rbx中
0x00007fffe101bac7: mov -0x8(%rbp),%rbx

// 移除栈帧
// leave指令相当于：
// mov %rbp, %rsp
// pop %rbp
0x00007fffe101bacb: leaveq
// 将返回地址弹出到%r13中
0x00007fffe101bacc: pop %r13
// 设置%rsp为调用者的栈顶值
0x00007fffe101bace: mov %rbx,%rsp
0x00007fffe101bad1: jmpq *%r13

第37篇-恢复调用者栈帧例程Interpreter::_invoke_return_entry
当控制权转移给调用者时，还需要恢复调用者的栈帧状态，如让%r13指向bcp、%r14指向局部变量表等，另外还需要弹出压入的实参、跳转到调用者的下一个字节码指令继续执行，而这一切操作都是由Interpreter::_return_entry例程负责的
当传递的state为itos（也就是当方法的返回类型为int时）时生成的汇编代码如下:
// 将-0x10(%rbp)存储到%rsp后，置空-0x10(%rbp)
0x00007fffe1006ce0: mov -0x10(%rbp),%rsp // 更改rsp
0x00007fffe1006ce4: movq $0x0,-0x10(%rbp) // 更改栈中特定位置的值
// 恢复bcp和locals，使%r14指向本地变量表，%r13指向bcp
0x00007fffe1006cec: mov -0x38(%rbp),%r13
0x00007fffe1006cf0: mov -0x30(%rbp),%r14
// 获取ConstantPoolCacheEntry的索引并加载到%ecx
0x00007fffe1006cf4: movzwl 0x1(%r13),%ecx 
 
// 获取栈中-0x28(%rbp)的ConstantPoolCache并加载到%ecx
0x00007fffe1006cf9: mov -0x28(%rbp),%rbx 
// shl是逻辑左移，获取字偏移
0x00007fffe1006cfd: shl $0x2,%ecx 
// 获取ConstantPoolCacheEntry中的_flags属性值
0x00007fffe1006d00: mov 0x28(%rbx,%rcx,8),%ebx
// 获取_flags中的低8位中保存的参数大小
0x00007fffe1006d04: and $0xff,%ebx 
 
// lea指令将地址加载到内存寄存器中，也就是恢复调用方法之前栈的样子
0x00007fffe1006d0a: lea (%rsp,%rbx,8),%rsp 
 
// 跳转到下一指令执行
0x00007fffe1006d0e: movzbl 0x3(%r13),%ebx 
0x00007fffe1006d13: add $0x3,%r13
0x00007fffe1006d17: movabs $0x7ffff73b7ca0,%r10
0x00007fffe1006d21: jmpq *(%r10,%rbx,8)

第38篇-解释方法之间的调用小实例
空白

第39篇-Java通过JNI调用C/C++函数
Java语言需要通过调用C/C++函数来实现某些功能，因为Java有时候对这些功能显的无能为力，
如想使用X86_64 的 SIMD 指令提升一下业务方法中关键代码的性能，又或者想要获取某个体系架构或者操作系统特有功能的支持

在对同步方法进行处理时，generate_normal_entry()函数中调用lock_method()函数生成例程，这个例程会对Java方法加锁而没有对应的释放锁逻辑，
因为dispatch_next()函数执行字节码指令时，一些字节码如return、athrow在移除栈帧的时候会有释放锁的操作，所以无须生成释放锁的逻辑，
但是generate_native_entry()函数生成的例程没有执行字节码指令，它必须在执行完native方法之后检查是否需要执行释放锁操作

JNI牺牲了可移植性，需要为不同平台生成动态链接库，另外在使用JNI机制开发时，还有一些缺点，如下：
从 Java 环境到 native code 的上下文切换耗时、低效；
JNI 编程，如果操作不当，可能引起 Java 虚拟机的崩溃；
JNI 编程，如果操作不当，可能引起内存泄漏。

本地函数的第一个参数JNIEnv接口指针，指向一个函数表，函数表中的每一个入口指向一个JNI函数。
本地函数经常通过这些函数来访问HotSpot中的数据结构，如堆中的oop等。

第40篇-JNIEnv和JavaVM
JNIEnv一般是是由虚拟机传入，而且与线程相关的变量，不是线程安全的:
struct JNIEnv_ {
    const struct JNINativeInterface_ *functions;
    ...
}
JNINativeInterface_定义了很多函数指针，指向对应的函数方法
struct JNINativeInterface_ {
    Java中的Class类相关的函数方法
    引用ref相关的函数方法
    获取jfieldID和jmethodID的函数方法
    ...
}

JavaVM是虚拟机在JNI中的表示，一个JVM中只有一个JavaVM实例，这个实例是线程共享的:
通过JNIEnv可以获取一个Java虚拟机实例: jint GetJavaVM(JNIEnv *env, JavaVM **vm)

struct JavaVM_ {
    const struct JNIInvokeInterface_ *functions;
    ...
}

跳过，代码分析比较浅显
第41篇-JNIEnv与JavaVM的初始化

未读跳过，暂时涉及不到
第42篇-JNI引用的管理（1）
第43篇-JNI引用的管理（2）


第44篇-为native方法生成解释执行入口
在HotSpot VM中，Java方法调用native方法会有2个入口例程，一个为解释执行的入口例程，一个为“编译”执行的入口例程。
所谓“编译”执行其实是如果一个native方法在解释模式被调用到了CompileThreshold次数之后，HotSpot VM会为该方法专门生成一个Native wrapper，将其方法属性、参数迁移之类的信息都固化进去，相比解释执行开销会小一些。
Native wrapper生成好之后会保存到方法的Method::_from_compiled_entry属性中。

InterpreterGenerator::generate_native_entry()函数生成解释执行的入口例程
在调用generate_fixed_frame()方法之前，会额外开辟2个8字节的空间，分别用来存放result_handler和oop temp
// 省略generate_fixed_frame()之前的汇编
// 省略generate_fixed_frame()生成的汇编

// 从栈帧中取出Method*存储到%rbx中
0x00007fffe1014d87: mov -0x18(%rbp),%rbx 
// 获取ConstMethod*存储到%r11中
0x00007fffe1014d8b: mov 0x10(%rbx),%r11 
// 将方法参数的大小放到%r11d中 
0x00007fffe1014d8f: movzwl 0x2a(%r11),%r11d 
// 将%r11d中的内容左移3位，也就是算出方法参数需要占用的字节数
0x00007fffe1014d94: shl $0x3,%r11d 
// 更新%rsp的值，为方法参数开辟存储参数的空间 
0x00007fffe1014d98: sub %r11,%rsp 
// 对linux系统来说不起作用 
0x00007fffe1014d9b: sub $0x0,%rsp 
// 必须是16字节边界（see amd64 ABI），System V / AMD64 ABI要求16字节堆栈对齐
0x00007fffe1014d9f: and $0xfffffffffffffff0,%rsp

// 将Method::signature_handler存储到%r11中
0x00007fffe1014da3: mov 0x68(%rbx),%r11
// 如果Method::signature_handler非空,则跳转到L1
0x00007fffe1014da7: test %r11,%r11
0x00007fffe1014daa: jne 0x00007fffe1014e40 

// 执行到这里，说明Method::signature_handler属性的值为空，
// 需要调用InterpreterRuntime::prepare_native_call()函数
// 确保native方法已经绑定且安装了方法签名解析代码
// 省略调用__call_VM()函数

// 将Method*存储到%rbx中 
0x00007fffe1014e38: mov -0x18(%rbp),%rbx
// 将Method::signature_handler放到%11中
0x00007fffe1014e3c: mov 0x68(%rbx),%r11 

// **** L1 ****
// 从这里开始执行如下的代码逻辑时，Method::signature_handler已经放到了%r11中

// 调用Method::signature_handler函数
0x00007fffe1014e40: callq *%r11 
// 调用signature_handler，解析方法参数，整个
// 过程一般不会改变rbx，但是慢速处理时可能导致GC，
// 所以调用完成后最好重新获取Method
0x00007fffe1014e43: mov -0x18(%rbp),%rbx
// 将%rax中的result_handler存储到方法栈帧中，result_handler
// 是执行signature_handler例程后的返回值，根据方法签名的返回类型获取的
0x00007fffe1014e47: mov %rax,0x18(%rbp)

// 将Method::access_flags存储到%r11d中
0x00007fffe1014e4b: mov 0x28(%rbx),%r11d 
// 判断是否为static本地方法，其中$0x8表示JVM_ACC_STATIC
0x00007fffe1014e4f: test $0x8,%r11d 
// 如果为0,表示是非static方法，要跳转到-- L2 --
0x00007fffe1014e56: je 0x00007fffe1014e74 

// 执行这里代码时，说明方法是static方法
// 如下4个mov指令将通过Method->ConstMehod->ConstantPool->mirror
// 获取到java.lang.Class的oop
0x00007fffe1014e5c: mov 0x10(%rbx),%r11
0x00007fffe1014e60: mov 0x8(%r11),%r11
0x00007fffe1014e64: mov 0x20(%r11),%r11
0x00007fffe1014e68: mov 0x70(%r11),%r11
// 将mirror存储到栈帧中，也就是oop temp这个slot位置
0x00007fffe1014e6c: mov %r11,0x10(%rbp)
// 将mirror拷到%rsi中作为静态方法调用的第2个参数
0x00007fffe1014e70: lea 0x10(%rbp),%rsi

// **** L2 ****
// 不管是静态还是非静态方法，都会执行如下的汇编片段

// 获取Method::native_function的地址并存储到%rax中
0x00007fffe1014e74: mov 0x60(%rbx),%rax 
// %r11中存储的是SharedRuntime::native_method_throw_unsatisfied_link_error_entry()
0x00007fffe1014e78: movabs $0x7ffff6a08f14,%r11 
// 判断rax中的地址是否是native_method_throw_unsatisfied_link_error_entry的地址，如果是说明本地方法未绑定
0x00007fffe1014e82: cmp %r11,%rax
// 如果不等于，即native方法已经绑定，跳转到----L3----
0x00007fffe1014e85: jne 0x00007fffe1014f1b 

// 执行这里的代码，说明native方法没有绑定，
// 调用InterpreterRuntime::prepare_native_call()函数重试，完成native方法绑定

// 重新获取Method*到%rbx中
0x00007fffe1014f13: mov -0x18(%rbp),%rbx 
// 获取native_function的地址拷到%rax中
0x00007fffe1014f17: mov 0x60(%rbx),%rax

// **** L3 ****
/ 将当前线程的JavaThread::jni_environment放入c_rarg0，也就是%rdi中
0x00007fffe1014f1b: lea 0x210(%r15),%rdi

// 将last_java_fp存储到JavaThread::JavaFrameAnchor::last_java_fp
0x00007fffe1014f22: mov %rbp,0x200(%r15) 
// 将last_java_pc存储到JavaThead::JavaFrameAnchor::last_java_pc
0x00007fffe1014f29: movabs $0x7fffe1014f22,%r10 
0x00007fffe1014f33: mov %r10,0x1f8(%r15) 
// 将last_java_sp保存到JavaThead.JavaFrameAnchor.last_java_pc中
0x00007fffe1014f3a: mov %rsp,0x1f0(%r15)

// 将线程的状态改成_thread_in_native
0x00007fffe1014f41: movl $0x4,0x288(%r15) 
// 调用native_function本地函数
0x00007fffe1014f4c: callq *%rax 

// 方法调用结束校验或者恢复CPU控制状态
0x00007fffe1014f4e: vzeroupper 
// 如下4行代码是为了保存调用native_function函数后得到的结果，将
// 结果存储到栈顶
0x00007fffe1014f51: sub $0x10,%rsp
0x00007fffe1014f55: vmovsd %xmm0,(%rsp)
0x00007fffe1014f5a: sub $0x10,%rsp
0x00007fffe1014f5e: mov %rax,(%rsp)

// 改变线程的状态为_thread_in_native_trans
0x00007fffe1014f62: movl $0x5,0x288(%r15)

// 调用MacroAssembler::serialize_memory()函数
0x00007fffe1014f6d: mov %r15d,%r11d
0x00007fffe1014f70: shr $0x4,%r11d
0x00007fffe1014f74: and $0xffc,%r11d
0x00007fffe1014f7b: movabs $0x7ffff7ff5000,%r10
// 结束MacroAssembler::serialize_memory()函数

// check for safepoint operation in progress and/or pending suspend requests
// 判断安全点的状态是否为_not_synchronized
0x00007fffe1014f85: mov %r11d,(%r10,%r11,1)
0x00007fffe1014f89: cmpl $0x0,0x1639454d(%rip) # 0x00007ffff73a94e0
// 如果不相等，则处于安全点，跳转到---- L ----
0x00007fffe1014f93: jne 0x00007fffe1014fa7

// 判断当前线程的suspend_flags是否为0，如果
// 是0则跳转到---- Continue ----，表示没有未处理的异常
0x00007fffe1014f99: cmpl $0x0,0x30(%r15)
0x00007fffe1014fa1: je 0x00007fffe1014fbd

// **** L ****
// 执行这里汇编时，说明处于安全点并且有未处理的异常

// 将JavaThread存储到c_rarg0中
0x00007fffe1014fa7: mov %r15,%rdi 
// 临时将%rsp存储到%r12中
0x00007fffe1014faa: mov %rsp,%r12 
// linux下不起作用
0x00007fffe1014fad: sub $0x0,%rsp 
// 栈按16字节对齐
0x00007fffe1014fb1: and $0xfffffffffffffff0,%rsp 
// 调用JavaThread::check_special_condition_for_native_trans()函数
0x00007fffe1014fb5: callq 0x00007ffff6aaf360
// 恢复%rsp 
0x00007fffe1014fba: mov %r12,%rsp 


// **** Continue ****
// 线程状态调整为_thread_in_Java，表示running in Java or in stub code
0x00007fffe1014fbd: movl $0x8,0x288(%r15) 

// 如下汇编清空JavaThead::JavaFrameAnchor::last_java_fp、last_java_sp与last_java_pc
0x00007fffe1014fc8: movabs $0x0,%r10
0x00007fffe1014fd2: mov %r10,0x1f0(%r15)
0x00007fffe1014fd9: movabs $0x0,%r10
0x00007fffe1014fe3: mov %r10,0x200(%r15)
0x00007fffe1014fea: movabs $0x0,%r10
0x00007fffe1014ff4: mov %r10,0x1f8(%r15)

// 将JavaThread::active_handles（类型为JNIHandleBlock）存储到%r11中
0x00007fffe1014ffb: mov 0x38(%r15),%r11
// 将JavaThread::active_handles::_top属性置为NULL
0x00007fffe1014fff: movq $0x0,0x108(%r11)
// 这里释放掉了整个JavaThread::active_handles保存的单链接JNIHandleBlock中的所有句柄了，因为第1个JNIHandleBlock的_top属性已经为0。这样的操作会让本地函数的局部对象引用全部变为无效状态

// If result is an oop unbox and store it in frame where gc will see it
// and result handler will pick it up
// 从AbstractInterpreter::_native_abi_to_tosca数组中获取对应返回类型的result_handler
0x00007fffe101500a: movabs $0x7fffe100ecdb,%r11

// 比较方法的结果处理程序result_handler是否是T_OBJECT类型的
0x00007fffe1015014: cmp 0x18(%rbp),%r11

// 如果不是则跳转到----no_oop----
0x00007fffe1015018: jne 0x00007fffe101503e
// 如果是，先把栈顶的long类型的数据，即oop地址pop出来放到rax中
0x00007fffe101501e: mov (%rsp),%rax
0x00007fffe1015022: add $0x10,%rsp
0x00007fffe1015026: test %rax,%rax

// 如果为0,跳转到----store_result----
0x00007fffe1015029: je 0x00007fffe1015032 
// 如果不为0,那么就表示有返回的oop，注意这里的操作，因为本地函数返回的
// 是句柄，所以要从句柄中获取到真正的oop地址
0x00007fffe101502f: mov (%rax),%rax

// **** store_result ****

// 将%rax中的值存储到栈的oop tmp中
0x00007fffe1015032: mov %rax,0x10(%rbp) 
0x00007fffe1015036: sub $0x10,%rsp
// 重新将%rax中的oop放到栈顶 
0x00007fffe101503a: mov %rax,(%rsp) 

// **** no_oop ****
// 判断当前线程的_stack_guard_state属性是否是stack_guard_yellow_disabled，即是否发生了stack overflow
0x00007fffe101503e: cmpl $0x1,0x2b4(%r15)
// 如果不等于，即没有发生stack overflow，则跳转到-- no_reguard --
0x00007fffe1015049: jne 0x00007fffe1015109

// 如果发生stack overflow，则调用reguard_yellow_pages做必要的处理
//...

// **** no_guard ****
// 重新加载Method
0x00007fffe1015109: mov -0x18(%rbp),%rbx
0x00007fffe101510d: mov 0x10(%rbx),%r13
// 获取ConstMethod::code的地址存储到%r13中
0x00007fffe1015111: lea 0x30(%r13),%r13

// 判断当前线程的_pending_exception属性是否为空，即是否发生了异常
0x00007fffe1015115: cmpq $0x0,0x8(%r15)
// 如果不为空，即没有异常，跳转到-- L --
0x00007fffe101511d: je 0x00007fffe101521f

// 当前线程的_pending_exception属性不为空，表示发生了异常
// 省略调用__ MacroAssembler::call_VM()函数生成例程来调用InterpreterRuntime::throw_pending_exception()函数
// 省略调用__ should_not_reach_here()生成的汇编

// **** L ****
// 判断目标方法是否是SYNCHRONIZED方法，如果是则需要解锁，如果不是则跳转到----L---- 
0x00007fffe101521f: mov 0x28(%rbx),%r11d
0x00007fffe1015223: test $0x20,%r11d
// 不需要解锁时直接跳转即可
0x00007fffe101522a: je 0x00007fffe1015405 
// 获取偏向锁BasicObjectLock的地址，存储到c_rarg1中
0x00007fffe1015230: lea -0x50(%rbp),%rsi
// 获取偏向锁的_obj属性的地址
0x00007fffe1015234: mov 0x8(%rsi),%r11 
0x00007fffe1015238: test %r11,%r11
// 判断_obj属性是否为空，如果不为空即未解锁，跳转到unlock完成解锁
0x00007fffe101523b: jne 0x00007fffe101533d

// 如果已解锁，说明锁的状态有问题，抛出异常
// 省略调用__ MacroAssembler::call_VM()函数生成的例程，这个例程用来调用InterpreterRuntime::throw_illegal_monitor_state_exception()函数
// 省略调用__ should_not_reach_here()生成的汇编

// 调用InterpreterMacroAssembler::unlock_object()函数 
// 将bcp保存到栈帧中
0x00007fffe101533d: mov %r13,-0x38(%rbp) 
// %rsi中存储的是BasicObjectLock，将BasicLock存储到%rax
0x00007fffe1015341: lea (%rsi),%rax 
0x00007fffe1015344: mov 0x8(%rsi),%rcx // 将_obj存储到%rcx中
0x00007fffe1015348: movq $0x0,0x8(%rsi) // 释放_obj属性
// 将_obj的markOop存储到%rdx中
0x00007fffe1015350: mov (%rcx),%rdx 
0x00007fffe1015353: and $0x7,%rdx 
0x00007fffe1015357: cmp $0x5,%rdx
// 如果已经是偏向状态，则跳转
0x00007fffe101535b: je 0x00007fffe1015401 

// 不为偏向状态
// 将BasicLock中的markOop存储到%rdx中
0x00007fffe1015361: mov (%rax),%rdx
0x00007fffe1015364: test %rdx,%rdx
// 如果为0,说明是锁的重入，跳转
0x00007fffe1015367: je 0x00007fffe1015401 
// 原子交换回原markOop，其中的%rdx中存储的就是old markOop，而%rcx中存储的是_obj
0x00007fffe101536d: lock cmpxchg %rdx,(%rcx) 
// 如果为0,说明是锁的重入，跳转
0x00007fffe1015372: je 0x00007fffe1015401 
// 执行这个汇编，说明为非锁重入
0x00007fffe1015378: mov %rcx,0x8(%rsi) // restore obj

// 省略调用call_VM()函数来调用InterpreterRuntime::monitorexit()函数

// 恢复bcp
0x00007fffe1015401: mov -0x38(%rbp),%r13 
// 结束unlock_object()函数

// 省略调用notify_method_exit()生成的汇编

// restore potential result in edx:eax(表示64位数), call result handler to
// restore potential result in ST0 & handle result
// 将栈顶的代表方法调用结果的数据pop到%rax中

0x00007fffe101543c: mov (%rsp),%rax
0x00007fffe1015440: add $0x10,%rsp
0x00007fffe1015444: vmovsd (%rsp),%xmm0
0x00007fffe1015449: add $0x10,%rsp
// 获取result_handler存储到%r11中
0x00007fffe101544d: mov 0x18(%rbp),%r11
// 调用result_handler处理方法调用结果
0x00007fffe1015451: callq *%r11 

// 获取sender sp，开始恢复上一个Java栈帧
0x00007fffe1015454: mov -0x8(%rbp),%r11 
// 相当于指令mov %ebp,%esp和pop %ebp
0x00007fffe1015458: leaveq 
// 获取return address
0x00007fffe1015459: pop %rdi 
// 设置sender sp
0x00007fffe101545a: mov %r11,%rsp 
// 跳转到返回地址处继续执行 
0x00007fffe101545d: jmpq *%rdi

第45篇-查找native方法的本地实现函数native_function
通过JNI_OnLoad()函数执行的时候调用了RegisterNatives()函数注册了函数地址信息
static JNINativeMethod method = { // 本地方法描述
    "getName", // Java方法名
    "(I)Ljava/lang/String;", // Java方法签名
    (void*) getName // 绑定到对应的本地函数
};

static bool bindNative(JNIEnv *env) {
    jclass clazz;
    clazz = env->FindClass(CLASS_NAME);
    if(clazz == NULL) {
        return false;
    }
    return env->RegisterNatives(clazz, &method, 1) == 0;
}

通过InterpreterRuntime::prepare_native_call()函数为Method::native_function赋值:
InterpreterRuntime::prepare_native_call()
NativeLookup::lookup()
NativeLookup::lookup_entry()
NativeLookup::lookup_style()

NativeLookup::lookup_entry() 会进行4次lookup_style:
其实对linux来说，第1次和第3次的查找逻辑一样，第2次和第4次的查找逻辑一样，所以我们只看第1次和第2次的查找逻辑即可。
第1次: pure_jni_name()函数拼接出来的函数名称是“Java_Java程序的package路径_函数名”
如果有重载的native方法，那么按第1次查找时生成的函数名称是无法查找到的，还需要在生成的函数名称中加上参数相关信息
第2次: long_jni_name()函数拼接出来的函数名称带参数类型

address NativeLookup::lookup_style(){
  Handle loader(THREAD, method->method_holder()->class_loader());
  // 当loader为NULL时，表示method所属的类是通过系统类加载器加载的
  if (loader.is_null()) {
    // 如果是查找registerNatives()函数，则直接返回实现函数的地址
    entry = lookup_special_native(jni_name);
    if (entry == NULL) {
       // 查找本地动态链接库,Linux下则是libjava.so
       void* tmp = os::native_java_library();
       // 找到本地动态链接库，调用os::dll_lookup查找符号表
       entry = (address) os::dll_lookup(tmp, jni_name);
    }
    if (entry != NULL) {
      in_base_library = true;
      return entry;
    }
  }
  // 省略调用java.lang.ClassLoader中的findNative()方法查找

  if (entry == NULL) {
      // findNative didn't find it, if there are any agent libraries look in them
      AgentLibrary* agent;
      for (agent = Arguments::agents(); agent != NULL; agent = agent->next()) {
        // 找到本地动态链接库，调用os::dll_lookup查找符号表
        entry = (address) os::dll_lookup(agent->os_lib(), jni_name);
        if (entry != NULL) {
          return entry;
        }
      }
  }
}
我们可以从3个地方来查找动态链接库:
（1）如果native方法所属的类是系统类加载器加载的，那么系统类加载器中的native方法的本地函数实现一般会在libjava.so中。
（2）如果在libjava.so中没有找到，则调用java.lang.ClassLoader.findNative()方法进行查找。调用java.lang.ClassLoader.findNative()方法能够查找到用户自己创建出的动态链接库，
    如我们编写native方法时，通常会通过System.load()或System.loadLibrary()方法加载动态链接库，这2个方法最终会调用到ClassLoader.loadLibrary()方法将相关的动态链接库保存下来供findNative()方法查找；
（3）如果步骤1和步骤2都没有找到，则从加载的代理库中查找，如我们在虚拟机启动时配置的-agentlib或attach到目标进程后发送load命令加载的动态链接库都有可以包含本地函数的实现

第46篇-signature_handler与result_handler
signature_handler:
Method实例的第2个额外slot的signature_handler指向的例程用来消除Java解释器栈和C/C++栈调用约定的不同，将位于解析器栈中的参数适配到本地函数使用的C栈

// 根据方法签名解析方法参数的解析器，当方法参数大小小于Fingerprinter::max_size_of_parameters
// 时可以生成并使用根据方法签名定制的快速的解析器，否则使用通用的相对较慢的解析器。
void SignatureHandlerLibrary::add(methodHandle method) {
  // 只有在signature_handler的值为NULL时才会执行如下逻辑，否则不做任何操作
  if (method->signature_handler() == NULL) {
    int handler_index = -1;
    // UseFastSignatureHandlers的值默认为true
    // Fingerprinter::max_size_of_parameters的值为13,也就是13个字节
    if (UseFastSignatureHandlers && method->size_of_parameters() <= Fingerprinter::max_size_of_parameters) {
      MutexLocker mu(SignatureHandlerLibrary_lock);
      // 确保使用到的相关变量都已经初始化完成
      initialize();
      // lookup method signature's fingerprint
      // 读出Method::_constMethod::_fingerprinter的值，也就是
      // 根据方法签名得到对应的指纹值，然后在_fingerprints数组中查找到
      // 句柄下标索引，由于句柄存储在_handlers数组中，所以可以根据这个下标
      // 索引从_handlers数组中获取
      uint64_t fingerprint = Fingerprinter(method).fingerprint();
      handler_index = _fingerprints->find(fingerprint);
      // 如果handler_index小于0,则说明没有这个方法签名对应的signature_handler，需要创建一个新的
      // signature_handler
      if (handler_index < 0) {
        ResourceMark rm;
        ptrdiff_t align_offset = (address)round_to((intptr_t)_buffer, CodeEntryAlignment) - (address)_buffer;
 
        CodeBuffer buffer(
                 (address)(_buffer + align_offset),
                 SignatureHandlerLibrary::buffer_size - align_offset
               );
        // 生成signature_handler，其实就是生成一段例程，这段例程可消除Java解释器栈
        // 和C/C++栈调用约定的不同，将位于解析器栈中的参数适配到本地函数使用的C栈
        InterpreterRuntime::SignatureHandlerGenerator tmp = InterpreterRuntime::SignatureHandlerGenerator(method, &buffer);
        tmp.generate(fingerprint);
        // signature_handler对应的例程临时保存在了CodeBuffer中，调用set_handler保存到BufferBlob中，
        // 这个BufferBlob中的内存是从CodeCache中分配出来的，解释执行所需要的所有例程基本都保存在CodeCache中
        address handler = set_handler(&buffer);
        if (handler == NULL) {
          // 使用普通的、相对较慢的解释器
        } else {
          // 向_fingerprints和_handlers数组中添加方法签名和signature_handler，这样下次就可以
          // 根据方法签名快速定位对应的signature_handler
          _fingerprints->append(fingerprint);
          _handlers->append(handler);
          handler_index = _fingerprints->length() - 1;
        }
      } // 结束 if (handler_index < 0)
 
      if (handler_index < 0) {
      // 使用通用的相对较慢的解析器
      address tmp = Interpreter::slow_signature_handler();
      method->set_signature_handler(tmp);
       } else {
      // 使用快速的解析器
      address tmp = _handlers->at(handler_index);
      method->set_signature_handler(tmp);
       }
    } else {
      // 没有快速的解释器，只能使用相对较慢的普通解释器
      method->set_signature_handler(Interpreter::slow_signature_handler());
    }
  }
}
对于参数不超过13个slot大小（int、byte、对象地址等占用一个slot，而double和long占用2个slot）的native方法来说，signature_handler会走快速路径
就是根据方法签名字符串得到一个64位的整数方法指纹（Method Fingerprint）值，后续signature_handler将直接用方法指纹值来解析参数。
方法指纹值都会存储在元素类型为uint64_t的数组中，所以方法指纹值不能超过64位大小，另外加上还需要存储结果类型、是否为静态方法等信息，
所以能表示方法参数类型的参数存储区只有52位大小，所以才会要求方法参数大小不超过13个slot的大小（每个参数的类型存储需要占用4位）。-XX:+PrintSignatureHandlers

注意解释执行栈Java方法的参数是从左向右入栈，而C/C++栈的参数是从右向左入栈

快速签名解析器
InterpreterRuntime::SignatureHandlerGenerator::generate()
SignatureIterator::iterate()
SignatureIterator::iterate_parameters()
    do_long()/do_object()/do_int()...
        pass_long()/pass_object()/pass_int()

void do_long(){ pass_long(); _jni_offset++; _offset += 2; }
其中的_jni_offset表示参数对于本地函数的偏移量，而_offset表示参数对于Java方法的偏移量。
对于Java方法来说，一个long或double会占用2个slot，而在64位下，本地函数只需要一个slot即可。一个slot占用一个wordSize。
pass_long()可以看到C/C++参数传递规则

普通的签名解析器
AbstractInterpreterGenerator::generate_slow_signature_handler()
// %rcx指向了栈顶，其中的栈顶值是第1个需要通过栈来给本地函数传递的参数
0x00007fffe1005400: mov %rsp,%rcx // 为调用准备c_rarg3
// 0x70=14*wordSize，其中wordSize=8，这里又从native栈帧上开辟了
// 14个slot，其中8个用来存储浮点数，5个用来存储整数，1个用来存储float/double identifiers
0x00007fffe1005403: sub $0x70,%rsp
//省略调用call_VM()函数生成的例程，这个例程调用InterpreterRuntime::slow_signature_handler()函数

// rax: result handler
// Do FP first so we can use c_rarg3 as temp
// 0x28等于5*wordSize
0x00007fffe1005492: mov 0x28(%rsp),%ecx // float/double identifiers

//我们暂时将需要通过寄存器传递的参数保存到新开辟过的14个slot中，而需要通过栈传递的参数放到param n ... param 1区域中即可
//省略把参数移动到14个slot的汇编代码，其中的%ecx中存储的是float/double identifiers，这是一个组合数字，
//指明8个浮点数slot中，哪些存储了float值，哪些存储了double值，然后分别使用vmovss和vmovsd移动到对应的寄存器中

// 恢复%rsp，0x70=14*wordSize
0x00007fffe10055a0: add $0x70,%rsp
0x00007fffe10055a4: retq

result_handler:
Interpreter::_native_abi_to_tosca[x] = generate_result_handler_for(type)
case T_OBJECT : move oop temp from stack to rax

47~49 空白
第47篇-解释执行的Java方法调用native方法小实例
第48篇-native方法调用解释执行的Java方法
第49篇-函数（方法）调用约定

第50篇-调用约定在HotSpot VM中的实现
当需要编译执行Java方法时，会调用SharedRuntime::java_calling_convention()函数

我们看到了这个类(VMRegPair)中定义了_first和_second这一对寄存器，这主要是为32位实现考虑的，因为32位在传递long或double类型的参数时，需要2个寄存器来完成，一个存储高32位，一个存储低32位。对于64位来说，通过只使用_first寄存器就可完成任务。
当_first的值小于32，表示使用通用寄存器来传递参数
当_first的值大于等于48，小于184，表示使用浮点寄存器来传递参数
当_first的值大于等于184时，表示对应的参数需要通过栈来传递

当需要执行native方法时，会调用SharedRuntime::c_calling_convention()函数

第51篇-SharedRuntime::generate_native_wrapper()生成编译入口
当统计到一个native方法被调用足够多次之后，HotSpot VM会为它专门生成编译执行的入口例程。这个入口例程的目的与生成解释执行的入口例程一样，都是因为调用约定不同，所以要进行栈帧布局和转换。
未读跳过，可以参考解释执行的入口例程

第52篇-即时编译器
参考pdf

第53篇-编译线程的初始化
时编译（Just In Time，JIT）的运行模式有两种：client模式（C1编译器）和server模式（C2编译器）。
这两种模式采用的编译器是不一样的，client模式采用的是代号为C1的轻量级编译器，特点是启动快，但是编译不够彻底；
而server模式采用的是代号为C2的编译器，特点是启动比较慢，但是编译比较彻底，所以一旦服务起来后，性能更高。
用户可以使用 -client 和 -server 参数强制指定虚拟机运行在 Client 模式或者 Server 模式(由于引入分层编译，此二者参数无法控制C1或C2进行编译)。而两者配合使用的方式称为“混合模式”（Mixed Mode）。
使用 -Xcomp 强制虚拟机运行于 “编译模式”（Compiled Mode），这时候将优先采用编译方式执行，但是解释器仍然要在编译无法进行的情况下接入执行过程。
当关闭分层编译的情况下（指定-XX:-TieredCompilation），Java虚拟机将直接采用 C2编译器编译。如果只想用 C1，可以在打开分层编译的情况下使用参数 -XX:TieredStopAtLevel=1

编译策略通常由CompilationPolicy来表示：
在实现分层编译之前，编译策略主要有两种实现，一种是SimpleCompPolicy，表示哪个方法触发编译就编译哪个方法；另一种是StackWalkCompPolicy，在触发编译的时候会遍历调用栈，看看是不是向上几层找个caller来编译的受益更大，找最大受益的caller来编译。
在实现多层编译之后，CompilationPolicy的任务还加上了为当前要编译的方法选择一个合适的编译路径去编译。
switch(CompilationPolicyChoice) {
  case 0:
    CompilationPolicy::set_policy(new SimpleCompPolicy());
    break;
  case 1: // 需要在C2编译器可用情况下才能选择此选项
    CompilationPolicy::set_policy(new StackWalkCompPolicy());
    break;
  case 2: // 需要在支持分层编译情况下才能选择此选项
    CompilationPolicy::set_policy(new SimpleThresholdPolicy());
    break;
  case 3: // 需要在支持分层编译情况下才能选择此选项 server模式默认是3
    CompilationPolicy::set_policy(new AdvancedThresholdPolicy());
    break;
AdvancedThresholdPolicy添加了_start_time和_increase_threshold_at_ratio两个属性，前者表示启动时间，后者表示当CodeCache已使用了指定比例时提升C1编译的阈值
在64位JVM中，有2种情况来计算总的编译线程数，如下：
    -XX:+CICompilerCountPerCPU=true， 默认情况下，编译线程的总数根据处理器数量来调整；
    -XX:+CICompilerCountPerCPU=false且-XX:+CICompilerCount=N，强制设定总编译线程数。
无论以上哪种情况，HotSpot VM都会将这些编译线程按照1:2的比例分配给C1和C2。

CompileBroker::init_compiler_threads
分别创建C1和C2编译的CompileQueu队列，所有的编译任务都需要入到队列中，然后由创建出来的编译线程从队列中获取到编译任务进行编译。

第54篇-方法调用计数
编译策略依赖于性能计数，所以HotSpot VM中有许多性能统计相关的代码，如统计方法调用次数和统计回边的次数(计数器Counter)，有了这些统计信息，HotSpot VM就会判断出是否为热点代码，是否需要触发即时编译，这样的行为称为热点探测（Hot Spot Detection）。
HotSpot VM是基于计数器的热点探测（Counter Based Hot Spot Detection），也就是为每个方法（代码块）建立计数器：
对于方法调用来说，调用次数超过阈值后形成热点，然后提交编译任务给后台编译线程，编译完成后通过适配器对原来字节码的调用转换成对本地代码的调用；
对于热点代码块来说，如for循环的次数超过阈值形成热点，然后会尽可能的立即完成编译，并且在完成必要的栈帧迁移转换(!!!)后立即执行编译后的本地代码，即完成OSR

MethodData类中定义了一个_data属性，这个属性会记录函数运行状态下的数据。主要记录3部分的数据，一个是函数类型等运行相关统计数据，一个是参数类型运行相关统计数据，还有一个是extra扩展区保存着deoptimization的相关信息，是C2优化的基础；MethodCounters主要用于基于调用频率的热点方法或块的跟踪统计。

InvocationCounter
int _counter; // format: [count |carry|state]
count：第3-31位表示方法调用计数，每次方法调用加1（每增加一次计数，_counter的值要加8，因为低3位不用来计数），超过半衰周期未触发编译则数据减半，触发编译后调用 reset()函数重置 InvocationCounter 所有数据；
carry：第2位表示当前方法是否已被编译，方法调用计数器达到阈值并触发编译动作后，carry 被设置为1，表示该方法已被编译；
state：第0位和第1位表示超出阈值时的处理，枚举值由InvocationCounter类中的State枚举类定义，wait_for_nothing 表示方法调用次数超过阈值后不触发编译，wait_for_compile 表示方法调用次数超过阈值后触发编译。
// 执行方法编译的阈值
static int InterpreterInvocationLimit;
// 执行栈上替换的阈值
static int InterpreterBackwardBranchLimit;
// 收集解释器执行性能数据的阈值
static int InterpreterProfileLimit;

InterpreterGenerator::generate_counter_incr()函数会生成统计的例程：
检查Method::_method_data和Mehod::_method_counters属性是否为NULL，分别向其_counter属性增加调用计数，同时检查是否溢出并触发编译。
generate_counter_incr()函数会被如下函数调用：generate_normal_entry()函数或generate_native_entry()函数，
在开启了UseCompiler或CountCompiledCalls选项的情况下才会进行调用次数的统计。

// 在开启分层编译TieredCompilation和性能收集ProfileInterpreter情况下生成如下汇编代码
 
// 校验Method::_method_data属性非空，如果为空则跳转到----no_mdo----
0x00007fffe1010490: mov 0x18(%rbx),%rax
0x00007fffe1010494: test %rax,%rax
0x00007fffe1010497: je 0x00007fffe10104b3
 
// 获取Method::_method_data::_invocation_counter::_counter并存储到%ecx
0x00007fffe1010499: mov 0x6c(%rax),%ecx
// 增加一次调用，一次调用需要增加8,因为_counter的后3位不表示计数
0x00007fffe101049c: add $0x8,%ecx
// 将增加调用次数后的值存储回Method::_method_data::_invocation_counter::_counter中
0x00007fffe101049f: mov %ecx,0x6c(%rax)
// 将更新后的Method::_method_data::_invocation_counter::_counter与1111111 000 进行与运算
0x00007fffe10104a2: and $0x3f8,%ecx
// 如果为0,就表示溢出，则跳转到----overflow----
0x00007fffe10104a8: je 0x00007fffe10104ae
// 如果计数没有溢出，则跳转到----done----
0x00007fffe10104ae: jmpq 0x00007fffe101056a

// **** no_mdo ****
 
// 调用InterpreterMacroAssembler::get_method_counters()函数
// 获取Method::_method_counters属
// 性的值后测试，如果不为0,则跳转到----has_counters----
0x00007fffe10104b3: mov 0x20(%rbx),%rax
0x00007fffe10104b7: test %rax,%rax
0x00007fffe10104ba: jne 0x00007fffe1010555
 
// 通过call_VM()函数生成例程来调用InterpreterRuntime::build_method_counters()函数

// 获取Method::_method_counters属性的值
// 后测试，如果仍然为0,则跳转到----done---- 
0x00007fffe1010548: mov 0x20(%rbx),%rax 
0x00007fffe101054c: test %rax,%rax 
0x00007fffe101054f: je 0x00007fffe101056a

// **** has_counters ****

// 更新Method::_method_counters::_invocation_counter::_counter属
// 性的值，如果此属性的值为0,则跳转到----overflow----
0x00007fffe1010555: mov 0x8(%rax),%ecx
0x00007fffe1010558: add $0x8,%ecx
0x00007fffe101055b: mov %ecx,0x8(%rax)
0x00007fffe101055e: and $0x3f8,%ecx
0x00007fffe1010564: je 0x00007fffe101056a

// **** done ****

// **** overflow ****

// ...省略不支持分层编译下的一些统计相关汇编代码
 
// **** invocation_counter_overflow ****
// 当计数器溢出或某个方法需要编译时跳转到此处

// 将c_rarg1寄存器的值设置为0
0x00007fffe1010b34: mov $0x0,%esi
// 调用call_VM()函数生成例程来调用InterpreterRuntime::frequency_counter_overflow()函数

// 恢复rbx中的Method*
0x00007fffe1010bbe: mov -0x18(%rbp),%rbx
// 跳转到----continue_after_compile----继续解释执行，在dispatch_next()函数生成的例程之前
0x00007fffe1010bc2: jmpq 0x00007fffe101096a

在解释执行的情况下，如果Method::_method_data属性的值不为NULL时，会优先增加此属性的调用计数相关的属性值（因为MethodData能更精确的记录更多运行时数据），
只有当Method::_method_data为空时，才会参考Method::_method_counters属性的值。在分层编译的情况下，一般会调用InterpreterRuntime::build_method_counters()函数创建的MethodCounters实例进行计数

第55篇-回边计数
对于控制转移指令来说，通常会调用TemplateTable::branch(bool is_jsr, bool is_wide)函数生成相关的汇编代码
TemplateTable::_goto()
// 将当前栈帧中保存的Method*拷贝到%rcx中
0x00007fffe101dd10: mov -0x18(%rbp),%rcx

// 如果开启了选项ProfileInterpreter，则执行分支跳转相关的性能统计
// %rax中保存着MDP（Method Data Pointer）
0x00007fffe101dd14: mov -0x20(%rbp),%rax
// 如果Method::_method_data的值为NULL，则跳转到---- profile_continue ----
0x00007fffe101dd18: test %rax,%rax
0x00007fffe101dd1b: je 0x00007fffe101dd39

// 代码执行到这里时，表示Method::_method_data的值不为NULL

// 根据Method::_method_data获取到JumpData::taken_off_set偏移处属性的值并存储到%rbx中
0x00007fffe101dd21: mov 0x8(%rax),%rbx
// 增加DataLayout::counter_increment，值为1
0x00007fffe101dd25: add $0x1,%rbx
// sbb是带借位减法指令
0x00007fffe101dd29: sbb $0x0,%rbx
// 存储回JumpData::taken_off_set偏移处
0x00007fffe101dd2d: mov %rbx,0x8(%rax)

// The method data pointer needs to be updated to reflect the new target.
// %rax中存储的是MethodData
// 根据MethodData获取JumpData::displacement_off_set偏移处的值
0x00007fffe101dd31: add 0x10(%rax),%rax
// 将%rax中存储的值更新到栈中interpreter_frame_mdx_offset偏向处
0x00007fffe101dd35: mov %rax,-0x20(%rbp)

//一个Java方法的字节码指令可能有多个回边，那么这些回边相关的运行时信息都会存储到_data属性指向的一片内存区域中。如上的JumpData::taken_off_set就是在MethodData::_data指向的一片内存区域的相对应位置存储跳转的次数

// **** profile_continue ****

// 将当前字节码位置往后偏移1字节处开始的2字节数据读取到%rdx中

0x00007fffe101dd39: movswl 0x1(%r13),%edx
// 将%rdx中的值字节次序变反
0x00007fffe101dd3e: bswap %edx
// 将%rdx中的值右移16位，上述两步就是为了计算跳转分支的偏移量
0x00007fffe101dd40: sar $0x10,%edx
// 将%rdx中的数据从2字节扩展成4字节
0x00007fffe101dd43: movslq %edx,%rdx
// 将当前字节码地址加上%rdx保存的偏移量，计算跳转的目标地址
0x00007fffe101dd46: add %rdx,%r13

// 校验rdx是否大于0，如果大于0说明是往前跳转，如果小于0说明是往后跳转，
// 如果大于0则跳转到---- dispatch ----，这样只有回边才会进行统计
0x00007fffe101dd49: test %edx,%edx
0x00007fffe101dd4b: jns 0x00007fffe101de30 

// 执行这里时，说明有回边需要统计
// 检查Method::_method_counters是否为NULL，如果非空则跳转到---- has_counters ----
0x00007fffe101dd51: mov 0x20(%rcx),%rax
0x00007fffe101dd55: test %rax,%rax
0x00007fffe101dd58: jne 0x00007fffe101ddf4

// 如果为空，则通过InterpreterRuntime::build_method_counters()函数创建一个新的MethodCounters

0x00007fffe101dde8: pop %rcx
0x00007fffe101dde9: pop %rdx
// 将创建出新的MethodCounters存储到%rax中
0x00007fffe101ddea: mov 0x20(%rcx),%rax
//如果创建失败，则跳转到到---- dispatch ----
0x00007fffe101ddee: je 0x00007fffe101de30

// **** has_counters ****

// 开启ProfileInterpreter性能收集才会生成的汇编

// 获取Method::_method_data属性到rbx中，并校验其是否为空，如果为空则跳转到 ---- no_mdo ----
0x00007fffe101ddf4: mov 0x18(%rcx),%rbx
0x00007fffe101ddf8: test %rbx,%rbx
0x00007fffe101ddfb: je 0x00007fffe101de17

//Method::_method_data属性不为空，则增加Method::_method_data::_backedge_counter
// 计数值，如果超过阈值则跳转到---- backedge_counter_overflow ----
0x00007fffe101ddfd: mov 0x70(%rbx),%eax
0x00007fffe101de00: add $0x8,%eax
0x00007fffe101de03: mov %eax,0x70(%rbx)
0x00007fffe101de06: and $0x1ff8,%eax
0x00007fffe101de0c: je 0x00007fffe101df22 
// 当没有超过阈值时，跳转到---- dispatch ----
0x00007fffe101de12: jmpq 0x00007fffe101de30

// **** no_mdo ****

// 增加Method::_method_counters::backedge_counter的调用计数，
// 如果超过阈值则跳转到---- backedge_counter_overflow ----
0x00007fffe101de17: mov 0x20(%rcx),%rcx
0x00007fffe101de1b: mov 0xc(%rcx),%eax
0x00007fffe101de1e: add $0x8,%eax
0x00007fffe101de21: mov %eax,0xc(%rcx)
0x00007fffe101de24: and $0x1ff8,%eax
0x00007fffe101de2a: je 0x00007fffe101df22 

// **** dispatch ****

// r13已经变成目标跳转地址，这里是加载跳转地址的第一个字节码到rbx中，然后执行
// 字节码指令的跳转逻辑
0x00007fffe101de30: movzbl 0x0(%r13),%ebx
0x00007fffe101de35: movabs $0x7ffff73b9e40,%r10
0x00007fffe101de3f: jmpq *(%r10,%rbx,8)

// 只有开启UseOnStackReplacement时才会生成如下汇编
// 当超过阈值后会跳转到此分支

// **** backedge_counter_overflow ****

// 对rdx中的数取补码
0x00007fffe101df22: neg %rdx
// 将r13的地址加到rdx上，这两步是计算跳转地址
0x00007fffe101df25: add %r13,%rdx

// 回边计数达到阈值后，会
// 通过调用call_VM()函数来调用InterpreterRuntime::frequency_counter_overflow()函数

// 恢复待执行的字节码
0x00007fffe101dfb0: movzbl 0x0(%r13),%ebx

// %rax存放编译的结果，如果为NULL，则表示还没有合适的编译结果，否则需要执行栈上替换操作
// 校验frequency_counter_overflow()函数返回的编译结果是否为空，
// 如果为空则跳转到----dispatch----，即继续解释执行字节码
0x00007fffe101dfb5: test %rax,%rax
0x00007fffe101dfb8: je 0x00007fffe101de30

// 如果不为空，即表示方法编译完成，将nmethod::_entry_bci属性的偏移复制到rcx中
0x00007fffe101dfbe: mov 0x48(%rax),%ecx
// 如果rcx等于InvalidOSREntryBci，则跳转到----dispatch----
0x00007fffe101dfc1: cmp $0xfffffffe,%ecx
0x00007fffe101dfc4: je 0x00007fffe101de30

// 开始执行栈上替换
// 注意%rax中已经存储了编译的结果，所以执行这段编译就是执行栈上替换，不过在执行
// 之前，还需要将解释栈转换为编译栈，因为2者的调用约定完全不同

// 将%rax中的值暂时存储在%r13中，因为调用如下的OSR_migration_begin()函数可能
// 会破坏%rax中存储的值
0x00007fffe101dfca: mov %rax,%r13 

// 通过调用call_VM()函数调用SharedRuntime::OSR_migration_begin()函数完成栈帧上变量和monitor的迁移

// 此时的%rax中存储的是OSR buffer，将其做为第1个参数传递给OSR编译后生成的代码
// 将%rax中的值拷贝到%rsi(j_rarg0)
0x00007fffe101e052: mov %rax,%rsi

// 获取interpreter_frame_sender_sp_offset偏移处的值
0x00007fffe101e055: mov -0x8(%rbp),%rdx
// leaveq相当于: movq %rbp,%rsp和pop %rbp
0x00007fffe101e059: leaveq

// 将返回地址弹出到%rcx中
0x00007fffe101e05a: pop %rcx 
0x00007fffe101e05b: mov %rdx,%rsp 
// -StackAlignmentInBytes的值为$0xfffffffffffffff0，确保栈是按8字节对齐的
0x00007fffe101e05e: and $0xfffffffffffffff0,%rsp
// 将返回地址压入栈中
0x00007fffe101e062: push %rcx

// 跳转到nmethod::_osr_entry_point，开始执行
0x00007fffe101e063: jmpq *0x88(%r13)

第56篇-ProfileData与DataLayout
class MethodData : public Metadata {

  // 这个值是为了更快的通过字节码下标索引找到对应data的指针（调用bci_to_dp()函数）
  // 或通过字节码下标索引找到对应的ProfileData（调用bci_to_data()函数）
  int     _hint_di;

  // 对回边和方法调用进行计数
  InvocationCounter _invocation_counter;
  InvocationCounter _backedge_counter;

  // 开始计数时的初始值
  int               _invocation_counter_start;
  int               _backedge_counter_start;

  int       _data_size;

  // 形参的data索引，如果没有，此值为-1
  int       _parameters_type_data_di;

  // 数据的起始地址
  intptr_t  _data[1];
  
  // ...
}
class ProfileData : public ResourceObj {
  DataLayout* _data;
  // ...
}
除去MethodData本身占用的内存外，还会额外分配不少内存(数组)用来存储统计相关的信息ProfileData，MethodData::_data是这个数组的首地址，而统计信息具有各种子类，每个子类大小不一，其数据的布局由DataLayout决定
DataLayout：
tag: 这个属性决定着ProfileData，也就是这一部分数据对应着哪个具体的ProfileData的子类，不同的子类其_cells数组的大小不同
_bci: 表示字节码索引，当前的_cells中存储的就是关于这个字节码的统计信息

调用MethodData::data_layout_at()获取到DataLayout指针后，可以直接根据布局中的_tag属性转换为ProfileData实例，通过ProfileData实例操作_cells中存储的数据
在分配MethodData实例时，需要调用如下函数计算分配的内存空间的大小MethodData::compute_allocation_size_in_bytes，除了要开辟自身占用的内存空间外，还要额外开辟另外的4部分空间：
1、为当前的字节码计算需要的统计信息占用的内存大小，因为只有部分字节码需要统计信息；(对于方法调用来说，有时候还需要统计方法的参数或返回值)
2、计算用来跟踪陷阱(ProfileTraps)的统计信息占用的内存大小，当激进优化的假设不成立，出现 “罕见陷阱”（Uncommon Trap）时可以通过逆优化退回到解释状态继续执行。
3、4、方法参数相关的统计
然后调用MethodData::initialize_data和post_initialize进行ProfileData初始化
BranchData : JumpData : ProfileData
taken        taken
displacement displacement
not_taken
BranchData 3个属性: taken命中计数器，not_taken未命中计数器，displacement调整MethodData指针指向(taken时)跳转目标的字节码对应的ProfileData，如果跳转后的字节码没有对应的ProfileData则指向limit_data_position(MethodData::bci_to_dp)

第57篇-profile实例
goto字节码指令调用的TemplateTable::branch()函数中会调用InterpreterMacroAssembler::profile_taken_branch()函数，生成的汇编代码如下：
// 如果开启了选项ProfileInterpreter，则执行分支跳转相关的性能统计

// %rax中保存着mdp（method data pointer）
0x00007fffe101dd14: mov -0x20(%rbp),%rax
// 如果Method::_method_data的值为NULL，则跳转到---- profile_continue ----
0x00007fffe101dd18: test %rax,%rax
0x00007fffe101dd1b: je 0x00007fffe101dd39

// 代码执行到这里时，表示Method::_method_data的值不为NULL
// 根据Method::_method_data获取到JumpData::taken_off_set偏移处属性的值并存储到%rbx中
0x00007fffe101dd21: mov 0x8(%rax),%rbx
// 增加DataLayout::counter_increment，值为1
0x00007fffe101dd25: add $0x1,%rbx
// sbb是带借位减法指令
0x00007fffe101dd29: sbb $0x0,%rbx
// 存储回JumpData::taken_off_set偏移处
0x00007fffe101dd2d: mov %rbx,0x8(%rax)

// %rax中存储的是method data pointer
// 根据method data pointer获取JumpData::displacement_off_set偏移处的值
0x00007fffe101dd31: add 0x10(%rax),%rax
// 将%rax中存储的值更新到栈中interpreter_frame_mdx_offset偏向处
0x00007fffe101dd35: mov %rax,-0x20(%rbp)
// ***** profile_continue *****
当Method::_method_data不为NULL时，会向MethodData::_data中记录控制转移的次数(注意这里是控制转移的次数，并不是回边的次数)

第58篇-触发编译
当计数值超过阈值时会调用InterpreterRuntime::frequency_counter_overflow()函数对方法或块进行编译，当为非OSR编译时，函数永远返回null，即不会立即执行编译，而是提交任务给后台编译线程编译；当为OSR编译时，传递的branch_bcp参数不为null，在调用的frequency_counter_overflow_inner()函数中通常会等待编译完成后才会返回
InterpreterRuntime::frequency_counter_overflow_inner(){
    ...
    // branch_bcp非空时获取其相对于方法字节码起始地址code_base的偏移，否则等于InvocationEntryBci，
    // InvocationEntryBci表明这是非栈上替换的方法编译
    constint branch_bci = branch_bcp != NULL? method->bci_from(branch_bcp) : InvocationEntryBci;
    constint bci = branch_bcp != NULL? method->bci_from(fr.interpreter_frame_bcp()) : InvocationEntryBci;

    // 获取编译策略
    CompilationPolicy* cp = CompilationPolicy::policy();
    // 如果要求栈上替换，返回该方法对应的nmethod；否则异步提交一个方法编译的任务给后台编译线程，然后返回NULL
    nmethod* osr_nm = cp->event(method, method, branch_bci, bci, CompLevel_none, NULL, thread);
    ...
}
nmethod* SimpleThresholdPolicy::event(){
  if (bci == InvocationEntryBci) {
    // 编译整个方法
    method_invocation_event(method, inlinee, comp_level, nm, thread);
  } else {
    // 编译热点代码
    method_back_branch_event(method, inlinee, bci, comp_level, nm, thread);
    nmethod* osr_nm = inlinee->lookup_osr_nmethod_for(bci, comp_level, false);
    if (osr_nm != NULL && osr_nm->comp_level() > comp_level) {
      return osr_nm;
    }
  }
  return NULL;
}
AdvancedThresholdPolicy::method_invocation_event(){
  if (should_create_mdo(mh(), level)) {
    // 创建MethodData实例并赋值给Method::_method_data属性
    create_mdo(mh, thread);
  }
  // 当前环境支持编译任务并且编译任务不再当前的编译队列中时，可能会编译
  if (is_compilation_enabled() && !CompileBroker::compilation_is_in_queue(mh, InvocationEntryBci)) {
    // 判断是否需要对方法进行编译
    CompLevel next_level = call_event(mh(), level);
    if (next_level != level) {
      compile(mh, InvocationEntryBci, next_level, thread);
    }
  }
}
bool AdvancedThresholdPolicy::should_create_mdo(){
  if (
      // 当前的方法在解释执行
      cur_level == CompLevel_none &&
      // 当编译队列中的CompLevel_full_optimization层
      // 级的任务小于（5*C2编译器线程数）时，表示编译器的负载小
      CompileBroker::queue_size(CompLevel_full_optimization) <= Tier3DelayOn * compiler_count(CompLevel_full_optimization)
  ) {
    int i = method->invocation_count();
    int b = method->backedge_count();
    double k = Tier0ProfilingStartPercentage / 100.0;
    // 方法调用次数 或 回边次数 是否超过阈值
    return call_predicate_helper<CompLevel_none>(i, b, k) || loop_predicate_helper<CompLevel_none>(i, b, k);
  }
}
SimpleThresholdPolicy::compile() {
  // 如果方法不能被C1编译器编译，则继续在解释执行情况下进行运行时信息的收集，然后用C2编译器编译
  if (!can_be_compiled(mh, level)) {<br> // 当要求C2编译器编译，并且
    if (level == CompLevel_full_optimization && can_be_compiled(mh, CompLevel_simple)) {
        compile(mh, bci, CompLevel_simple, thread); // 递归调用当前函数
    }
    return;
  }
  ...
  if (!CompileBroker::compilation_is_in_queue(mh, bci)) {
    submit_compile(mh, bci, level, thread);
  }
}
AdvancedThresholdPolicy::method_back_branch_event(){
  //跟method_invocation_event相似，略
}

第59篇-编译策略
在执行OSR或方法编译时，调用AdvancedThresholdPolicy::common()函数决定编译策略:
enum CompLevel {
  CompLevel_any = -1,
  CompLevel_all = -1,
 
  // level 0：解释执行
  CompLevel_none = 0, 
  // level 1：执行不带profiling的C1代码
  CompLevel_simple = 1, 
  // level 2：执行仅带方法调用次数以及循环回边执行次数profiling的C1代码
  CompLevel_limited_profile = 2, 
  // level 3：执行带所有profiling的C1代码
  CompLevel_full_profile = 3, 
  // level 4：执行C2代码 
  CompLevel_full_optimization = 4, 
 
  // 在分层编译的情况下仅使用C2进行编译，值为4,也就是level 4
  CompLevel_highest_tier = CompLevel_full_optimization, 
  CompLevel_initial_compile = CompLevel_full_profile
}
编译层级从一个层级转换到另外一个层级参考的主要指标有：方法统计的运行时信息和编译器线程的负载情况
编译策略路径参考图：
其中0、2、3这三个层级下都会周期性的通知AdvancedThresholdPolicy某个函数的方法调用计数（invocation counters）和循环调用计数（backedge counters），不同级别下通知的频率不同。这些通知用来决定如何调整编译层级，所以最终会形成不同的编译路径
在 5 个层次的执行状态中，CompLevel_simple和CompLevel_full_optimization为终止状态。当一个方法被终止状态编译后，如果编译后的代码没有失效，那么Java虚拟机是不会再次发出对该方法的编译请求的。

1、在CompLevel_none下不执行任何编译，仍然是解释执行当某个方法刚开始执行时，通常会解释执行。当C1和C2的编译任务队列的长度足够短，也可在CompLevel_none下开启profile信息收集。编译队列通过优先级队列实现，每个添加到编译任务队列的方法都会周期的计算其在单位时间内增加的调用次数，每次从编译队列中获取任务时，都选择单位时间内调用次数最大的一个。基于此，我们也可以将那些编译完成后不再使用，调用次数不再增加的方法从编译任务队列中移除。如果当前的编译层级为CompLevel_none，可能会变为CompLevel_limited_profile、CompLevel_full_profile、CompLevel_full_optimization编译层级。
2、CompLevel_none调整为CompLevel_limited_profile或CompLevel_full_profileAdvancedThresholdPolicy会综合如下两个因素和调用计数将编译级别调整为CompLevel_limited_profile或CompLevel_full_profile：
    C2编译任务队列的长度决定了下一个编译级别。据观察，CompLevel_limited_profile级别下的编译比CompLevel_full_profile级别下的编译快30%，因此我们应该在只有已经收集了充分的profile信息后才采用CompLevel_full_profile编译，从而尽可能缩短CompLevel_full_profile级别下编译的耗时。当C2的编译任务队列太长的时候，如果选择CompLevel_full_profile则编译会被卡住直到C2将之前的编译任务处理完成，这时如果选择CompLevel_limited_profile编译则很快完成编译。当C2的编译压力逐步减小，就可以重新在CompLevel_full_profile下编译并且开始收集profile信息；
    根据C1编译任务队列的长度动态的调整阈值，在编译器过载时，将打算编译但是不再被调用的方法从编译队列中移除。
3、CompLevel_full_profile调整为CompLevel_none、CompLevel_simple、CompLevel_full_optimization当CompLevel_full_profile下profile信息收集完成后就会转换成CompLevel_full_optimization了，可以根据C2编译任务队列的长度来动态调整转换的阈值。当经过C1编译完成后，基于方法的代码块的数量，循环的数量等信息可以判断一个方法是否是琐碎（trivial）的，这类方法在C2编译下会产生和C1编译一样的代码，因此这时会用CompLevel_simple的编译代替CompLevel_full_optimization的编译。
4、CompLevel_full_profile调整为CompLevel_full_optimization注意CompLevel_full_profile并不是终态，一般到了这个层次的编译任务最终都需要C2编译器承担CompLevel_full_optimization层级的编译任务，所以我们才会看到，当编译层级由其它的调整为CompLevel_full_profile时，通常会判断C2的负载能力。

编译层级从一个层级转换到另外一个层级参考的主要指标还需要参考运行时收集的信息，OSR编译主要是调用AdvancedThresholdPolicy::loop_predicate()函数
bool AdvancedThresholdPolicy::loop_predicate(int i, int b, CompLevel cur_level) {
  switch(cur_level) {
  case CompLevel_none:
  case CompLevel_limited_profile: {
    // Tier3LoadFeedback的值默认为5
    double k = threshold_scale(CompLevel_full_profile, Tier3LoadFeedback);
    // scale越小时，满足函数的判断条件需要的回边计数值就越小，更大机率被编译
    return loop_predicate_helper<CompLevel_none>(i, b, k);
  }
  case CompLevel_full_profile: {
    // Tier4LoadFeedback的值默认为3
    double k = threshold_scale(CompLevel_full_optimization, Tier4LoadFeedback);
    return loop_predicate_helper<CompLevel_full_profile>(i, b, k);
  }
  default:
    return true;
  }
}
double AdvancedThresholdPolicy::threshold_scale(CompLevel level, int feedback_k) {
  double queue_size = CompileBroker::queue_size(level); // 编译队列中编译任务的数量
  int comp_count = compiler_count(level); // 编译器线程数量
  // 当队列的任务越多时，scale的值越大；当编译的线程数量越多时，scale的值越小
  double k = queue_size / (feedback_k * comp_count) + 1;
 
  // 获取CodeCache的剩余可用空间，如果不足，则增加C1编译的阈值，从而为C2编译保留足够的空间
  if ((TieredStopAtLevel == CompLevel_full_optimization) && (level != CompLevel_full_optimization)) {
    double current_reverse_free_ratio = CodeCache::reverse_free_ratio();
    if (current_reverse_free_ratio > _increase_threshold_at_ratio) {
      k *= exp(current_reverse_free_ratio - _increase_threshold_at_ratio);
    }
  }
  return k;
}
第60篇-获取编译任务
在SimpleThresholdPolicy::compile()函数中会调用SimpleThresholdPolicy::submit_compile()函数提交编译任务：
nmethod* CompileBroker::compile_method(){
  ...
  // 如果是本地方法，且不是intrinsic相关方法，则调用NativeLookup加载对应的本地代码
  if (method->is_native() && !method->is_method_handle_intrinsic()) {
    bool in_base_library;
    address adr = NativeLookup::lookup(method, in_base_library, THREAD);
  }
    if (method->is_native()) {
       // PreferInterpreterNativeStubs表示是否总是使用解释器的stub调用本地方法，默认值为false
      if (!PreferInterpreterNativeStubs || method->is_method_handle_intrinsic()) {
        int compile_id;
        {
          MutexLocker locker(MethodCompileQueue_lock, THREAD);
          compile_id = assign_compile_id(method, standard_entry_bci);
        }
        // 注意这里调用的create_native_wrapper()函数为本地方法生成编译执行的入口，这在之前详细介绍过
        // 最终调用generate_native_wrapper()
        (void) AdapterHandlerLibrary::create_native_wrapper(method, compile_id);
      } else {
        return NULL;
      }
    } else {
      // 如果因为存储代码的CodeCache已经满了，则直接返回NULL，这样就不会阻塞方法的继续执行
      if (!should_compile_new_jobs()) {
         CompilationPolicy::policy()->delay_compilation(method());
         return NULL;
      }
      compile_method_base(method, osr_bci, comp_level, hot_method, hot_count, comment, THREAD);
    }
}
void CompileBroker::compile_method_base(){
    // 判断线程是否需要等编译任务完成后才继续执行，会判断BackgroundCompilation选项的值，默认为true，
    // 所以通常是后台编译，不需要等待
    // 当该方法有断点的时候并不进行编译，当参数-XX:-BackgroundCompilation设置成不是后台编译的时候，
    // 并不代表是在用户线程编译，而是提交任务CompileTask到CompileQueue，唯一的区别是堵塞当前线程等待
    // CompileThread直到Task编译成功
    blocking = is_compile_blocking(method, osr_bci);

    // 创建CompileTask任务，然后添加到C1或C2的任务队列中
    task = create_compile_task(...)

    // 如果blocking为true，表示需要等待编译任务完成后才能继续执行方法，如OSR编译
    if (blocking) {
      wait_for_completion(task);
    }
}

在创建虚拟机实例时会调用compilation_init()函数初始化CompileBroker，compilation_init()函数负责初始化编译相关组件，包括编译器实现，编译线程，计数器等。
其中还会调用CompileBroker::make_compiler_thread()函数，在这个函数中创建出对应的编译线程并启动，启动后的新线程线程会调用compiler_thread_loop()函数从CompileQueue中取任务进行编译。
启动的新的编译线程的调用栈如下：
clone() clone.S
start_thread() pthread_create.c
java_start() os_linux.cpp
JavaThread::run()                      thread.cpp
JavaThread::thread_main_inner()        thread.cpp
compiler_thread_entry() thread.cpp
CompileBroker::compiler_thread_loop()  compileBroker.cpp
{
    // 只有在没有断点的情况下才会进行编译
    if (method()->number_of_breakpoints() == 0) {
      // Compile the method.
      if ((UseCompiler || AlwaysCompileLoopMethods) &&
                  CompileBroker::should_compile_new_jobs()) {
        ...
        invoke_compiler_on_method(task); // 对编译任务进行编译
      } else {
        // 如果编译已经被禁止，则移除队列中的编译任务
        method->clear_queued_for_compilation();
      }
    }
}

第61篇-安装与卸载编译方法和OSR
调用compile_java_method()函数编译，这个函数是C1编译器或C2编译器的入口方法，编译完成后调用install_code()函数“安装”代码,
也就是调用ciEnv中的register_method()函数注册编译的方法（热点代码块也是以方法为单位编译的）:
  nm = nmethod::new_nmethod(...)
  //如果是非栈上替换
  if (entry_bci == InvocationEntryBci) {
    if (TieredCompilation) {
      // 如果有之前安装的版本，设置为不可用
      nmethod* old = method->code();
      if (old != NULL) {
        old->make_not_entrant();
      }
    }
    // nmethod安装到Method上，安装完成可以立即执行
    method->set_code(method, nm);
  } else { // 如果是栈上替换
    // 将其添加到Klass的osr_nmethods链表上
    method->method_holder()->add_osr_nmethod(nm);
  }
一般一个类被加载进来之后，里面的方法最早也要到它即将第一次被执行的时候才有可能被JIT编译器所编译。在那之前_code都是null
编译方法的安装与卸载
Method::set_code()
Method::clear_code()
栈上替换的安装与卸载
InstanceKlass::add_osr_nmethod()
InstanceKlass::remove_osr_nmethod()
当nmethod被标记成not_entrant或者zombie时，或者执行CodeCache垃圾回收时会调用卸载函数

第62篇-解释器与编译器适配
从adapter中调用get_i2c_entry()或get_c2i_entry()函数就可以在解释执行和编译执行之间进行适配，因为解释执行和编译执行的调用约定（calling convention）不同，所以要进行适配

// 需要进行类检测的入口
address           _entry_point; 
// 没有类检查的入口
address           _verified_entry_point;
每个Method有两个实际入口，一个是unverified entry point（UEP），用于实现虚方法分派的monomorphic inline cache；另一个是verified entry point（VEP），是方法的真正入口。
只有需要虚方法分派的方法才会有独立的UEP；对静态方法、私有成员方法之类的Java方法，UEP与VEP实际上在同一个位置，后面还会详细介绍UEP与VEP

AdapterHandlerEntry* AdapterHandlerLibrary::get_adapter(methodHandle method) {
    int total_args_passed = method->size_of_parameters();
 
    // 宏扩展后为：(BasicType*) resource_allocate_bytes( (total_args_passed) * sizeof(BasicType) )
    // BasicType为枚举类型，在之前介绍调用约定时详细介绍过
    BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, total_args_passed);
    // 宏扩展后为：(VMRegPair*) resource_allocate_bytes( (total_args_passed) * sizeof(VMRegPair) )
    VMRegPair* regs = NEW_RESOURCE_ARRAY(VMRegPair, total_args_passed);
 
    int i = 0;
    if (!method->is_static()){ 
      sig_bt[i++] = T_OBJECT; // 实例方法传递的第一个参数为this指针
    }
 
    for (SignatureStream ss(method->signature()); !ss.at_return_type(); ss.next()) {
      sig_bt[i++] = ss.type(); 
      if (ss.type() == T_LONG || ss.type() == T_DOUBLE){
        sig_bt[i++] = T_VOID; // 对于Long和Double类型来说，占用2个slot
      }
    }
    assert(i == total_args_passed, "");
    // 针对不同的方法签名生成不同的AdapterHandlerEntry，所以需要一个AdapterHandlerTable容器来存储
    // 这样，相同的方法签名就可以重用AdapterHandlerEntry，如果查找了，直接返回就可以
    entry = _adapters->lookup(total_args_passed, sig_bt);
    if (entry != NULL) {
      return entry;
    }
 
    // 根据java编译执行的调用约定计算出需要通过栈来传递的参数的栈大小
    int comp_args_on_stack = SharedRuntime::java_calling_convention(sig_bt, regs, total_args_passed, false);
 
    fingerprint = new AdapterFingerPrint(total_args_passed, sig_bt);

    entry = SharedRuntime::generate_i2c2i_adapters(
                   &_masm,
                   total_args_passed,
                   comp_args_on_stack,
                   sig_bt,
                   regs,
                   fingerprint
                  );

    _adapters->add(entry);
}

第63篇-解释器与编译器适配之SharedRuntime::gen_i2c_adapter()函数
adapter与入口的关系:
_from_interpreted_entry ->  _i2i_entry
                        ->  _adapter->i2c_entry
_from_compiled_entry    ->  _code->verified_entry_point
                        ->  _adapter->c2i_entry

// 针对不同的方法签名生成不同的AdapterHandlerEntry，
// 所以需要一个AdapterHandlerTable容器来存储
// 这样，相同的方法签名就可以根据fingerprint来
// 重用AdapterHandlerEntry
entry = SharedRuntime::generate_i2c2i_adapters(&_masm,
    // 方法需要传递参数的大小，准备来说，应该是slot的数量，如一个long参数需要2个slot
    total_args_passed, 
   // 根据java编译执行的调用约定计算出需要通过栈来传递的参数的栈大小
    comp_args_on_stack, 
    sig_bt,
    regs,
    fingerprint);
调用gen_i2c_adapter()生成i2c stub:(假设传递1个整数型参数)
// 在InterpreterMacroAssembler::jump_from_interpreted函数中已经
// 压入了栈顶地址，现在将此地址保存到%rax中
0x00007fffe110a1a0: mov (%rsp),%rax 
 
// ...

// 由于%rsp指向的地址在接下来要进行8字节对齐，所以需要保存原%rsp的值到%r11中
0x00007fffe110a267: mov %rsp,%r11
 
// 要保证在执行编译方法的代码时，栈的起始地址是按8字节对齐的
0x00007fffe110a26a: and $0xfffffffffffffff0,%rsp 
 
// 现在栈顶仍然是返回地址，不过已经进行了对齐操作，
// 所以可能已经不是以前存储的位置
0x00007fffe110a26e: push %rax
 
// 将原%rsp保存到%rax中，因为下面要通过原%rsp
// 来查看解释栈中传递的参数
0x00007fffe110a26f: mov %r11,%rax
 
// 获取Method:_from_compiled_entry值存储到%r11中
0x00007fffe110a272: mov 0x48(%rbx),%r11 

// saved_sp+0x8移动到%rsi，这是准备参数的
// 操作，%rsi是第1个参数用的指定寄存器
// 要记住，解释执行是通过栈来传递参数的，
// 所以要通过saved_sp+0x8来查找传递的
// 那个整数类型参数，而编译执行的调用约定
// 是通过%rsi来传递第1个参数的，所以要适配
0x00007fffe110a276: mov 0x8(%rax),%rsi 
// 将%rbx的值存储到JavaThread::_callee_target中，%rbx应该是Method*
0x00007fffe110a27a: mov %rbx,0x248(%r15) 
 
// put Method* where a c2i would 
// expect should we end up there
// only needed because of c2 resolve
// stubs return Method* as a result in rax
// 将Method*存储到%rax中，也是调用约定的一部分
0x00007fffe110a281: mov %rbx,%rax

// 跳转到Method::_from_compiled_entry开始执行
0x00007fffe110a284: jmpq *%r11


第64篇-C1编译器概述
C1编译器的大概编译流程: 字节码 -> HIR -> LIR -> 机器码
typedef enum {
 _t_compile, // C1编译
    _t_setup, // 1)设置C1编译环境
    _t_buildIR, // 2)构造HIR
        _t_hir_parse, // 从字节码生成HIR
        _t_gvn, // GVN优化
        _t_optimize_blocks, // 基本块优化
        _t_optimize_null_checks, // null检查优化消除
        _t_rangeCheckElimination, // 数组范围检查消除
    _t_emit_lir, // 3)构造LIR
        _t_linearScan, // 线性扫描寄存器分配
        _t_lirGeneration, // 生成LIR
    _t_codeemit, // 4)机器代码生成
    _t_codeinstall, // 5)替换解释执行的代码为机器代码(nmethod)
  max_phase_timers
} TimerName;
int Compilation::compile_java_method() {
  // ...
  // 1、构造HIR
  {
    build_hir();
  }
  // 2、构造LIR
  {
    _frame_map = new FrameMap(
        method(),
        hir()->number_of_locks(), 
        MAX2(4, hir()->max_stack()));
    emit_lir();
  }
  // 3、生成机器代码
  {
    return emit_code_body();
  }
}

第65篇-创建HIR
void Compilation::build_hir() {
  // 1、创建HIR
  _hir = new IR(this, method(), osr_bci());
 
  // 1.2、优化：条件表达式消除，基本块消除
  // UseC1Optimizations选项默认的值为true
  if (UseC1Optimizations) { 
    _hir->optimize_blocks();
  }
 
  _hir->split_critical_edges();
 
  // 为了更好的进行后续代码的生成，需要对基本块进行一个排序
  _hir->compute_code();
 
  // 1.3、优化：全局值编号优化
  if (UseGlobalValueNumbering) { 
    int instructions = Instruction::number_of_instructions();
    GlobalValueNumbering gvn(_hir);
  }
 
  // 1.4、优化：范围检查消除
  if (RangeCheckElimination) { 
    if (_hir->osr_entry() == NULL) {
      RangeCheckElimination::eliminate(_hir);
    }
  }
 
   // 1.5、优化：null检查消除
  if (UseC1Optimizations) { 
    _hir->eliminate_null_checks();
  }
 
  // 在全局值编号(GVN，Global Value Numbering)后计算使用次数
  _hir->compute_use_counts(); 
}
HIR的创建过程主要是创建控制流图和基本块:
在BlockListBuilder类的构造函数中调用了3个函数，分别是创建控制流图的首个基本块，创建所有基本块以及标出循环相关信息。
在MethodLiveness类的构造函数中也会调用3个函数，分别是初始化基本块，计算块中的活跃集以及传播活跃集。

创建控制流图的首个基本块:
void BlockListBuilder::set_entries(int osr_bci) {
  BlockBegin* std_entry = make_block_at(0, NULL); 
  // 获取IRScope中的_caller属性的值，这里暂时不考虑函数内联的情况
  // 所以_caller属性的值一般为NULL
  if (scope()->caller() == NULL) { 
    std_entry->set(BlockBegin::std_entry_flag);
  }
  // ...
}
BlockBegin* BlockListBuilder::make_block_at(int cur_bci, BlockBegin* predecessor) {
   BlockBegin* block = _bci2block->at(cur_bci);
   if (block == NULL) {
     block = new BlockBegin(cur_bci);
     // 初始化的_stores_to_locals属性是BitMap类型的实例
     block->init_stores_to_locals(method()->max_locals()); 
     // 有对_bic2block属性的操作
     _bci2block->at_put(cur_bci, block); 
     // 有对_blocks属性的操作
     _blocks.append(block); 
   }
   // 更新前驱和后继基本块的相关信息
   if (predecessor != NULL) {
     predecessor->add_successor(block);
     block->increment_total_preds();
   }
   return block;
}
_bci2block判断是否已经为当前的字节码指令建立了基本块，能避免重复创建基本块，例如在回边的时候，跳转的目标字节码指令可能已经有了对应的基本块
创建所有基本块:
void BlockListBuilder::set_leaders() {
  // 通过ciBytecodeStream迭代被编译方法中的所有字节码指令
  ciBytecodeStream s(method());
  while (s.next() != ciBytecodeStream::EOBC()) {
    int cur_bci = s.cur_bci();

    // 获取当前的字节码指令对应的基本块
    if (bci_block_start.at(cur_bci)) {
      current = make_block_at(cur_bci, current);
    }

    switch (s.cur_bc()) {
      // 省略其他return和throw
      case Bytecodes::_return:
        current = NULL;
        break;
      // 省略其他if
      case Bytecodes::_ifnonnull:
        make_block_at(s.next_bci(), current);
        make_block_at(s.get_dest(), current);
        current = NULL;
        break;
      case Bytecodes::_goto:
        make_block_at(s.get_dest(), current);
        current = NULL;
        break;
      // 省略jsr和jsr_w指令的实现逻辑
      // 省略_tableswitch 和 _lookupswitch

    }// end switch
  }
}
控制流图的基本块的划分原则是：
方法的第1个字节码指令(bci_block_start)
控制转移指令的目标位置
控制转移指令的下一条字节码指令

初始化基本块:
MethodLiveness::init_basic_blocks(){
   int method_len = method()->code_size();
   // 此函数填充ciMethodBlocks类中的_blocks（类型为ciBlock*）和_bci_to_block
   ciMethodBlocks *mblocks = method()->get_method_blocks();
 
   // 创建数组保存bci到BasicBlock的映射信息
   _block_map = new (arena()) GrowableArray<BasicBlock*>(arena(), method_len, method_len, NULL);
 
   _block_count = mblocks->num_blocks();
   _block_list = (BasicBlock **) arena()->Amalloc(sizeof(BasicBlock *) * _block_count);
 
   // Used for patching up ret control flow.
   GrowableArray<BasicBlock*>* ret_list = new GrowableArray<BasicBlock*>(5);

   // 根据ciMethodBlocks生成自己的_block_list，之前是ciBlock，现在是BasicBlock
   for (int blk = 0; blk < _block_count; blk++) {
      ciBlock *cib = mblocks->block(blk);
 
      int start_bci = cib->start_bci();
     _block_list[blk] = new (arena()) BasicBlock(this, start_bci, cib->limit_bci());
     _block_map->at_put(start_bci, _block_list[blk]);
 
     // 通过位来标记出基本块的第一个字节码指令
     _bci_block_start.set_bit(start_bci); 
   }
   // 省略BasicBlock链表的链接逻辑
}
ciMethodBlocks::ciMethodBlocks(Arena *arena, ciMethod *meth){
  int block_estimate = _code_size / 8;
  // _blocks的类型为GrowableArray<ciBlock *>*
  _blocks = new(_arena) GrowableArray<ciBlock *>(_arena, block_estimate, 0, NULL);

  int b2bsize = _code_size * sizeof(ciBlock **);
  // _bci_to_block的类型为ciBlock**
  _bci_to_block = (ciBlock **) arena->Amalloc(b2bsize);
  // 以_bci_to_block指向的地址开始进行初始化
  Copy::zero_to_words((HeapWord*) _bci_to_block, b2bsize / sizeof(HeapWord));

  // 创建ciBlock并追加到_blocks属性中
  ciBlock *b = new(arena) ciBlock(_method, _num_blocks++, 0);
  _blocks->append(b);
  _bci_to_block[0] = b;

  // ...
  // 遍历字节码指令并划分出基本块 
  do_analysis(); 
  // ... 
}
void ciMethodBlocks::do_analysis() {
  ciBytecodeStream s(_method);
  ciBlock *cur_block = block_containing(0); // 返回_bci_to_block[0]的值
  int limit_bci = _method->code_size();

  // 对字节码指令进行遍历
  while (s.next() != ciBytecodeStream::EOBC()) {
    int bci = s.cur_bci();

    // 查看当前的字节码指令是否还在cur_block块表示的范围内，如果是就返
    // 回cur_block；如果不是就创建一个新的，然后结束上一次的基本块
    ciBlock *new_block = block_containing(bci);
    if (new_block == NULL || new_block == cur_block) {
      // 当前的字节码指令还在创建出来的cur_block基本块表示的范围之内
      _bci_to_block[bci] = cur_block;
    } else {
      // 当前的字节码指令已经不属于当前的块，结束此块，将创建出的新块赋值给cur_block属性
      cur_block->set_limit_bci(bci);
      cur_block = new_block;
    }

    switch (s.cur_bc()) {
      // 省略其他if
      case Bytecodes::_ifnonnull :
        {
          cur_block->set_control_bci(bci);
          ciBlock *fall_through = make_block_at(s.next_bci());
          int dest_bci = s.get_dest();
          ciBlock *dest = make_block_at(dest_bci);
          break;
        }
      // 省略其他字节码
    }
  }
}
ciBlock *ciMethodBlocks::make_block_at(int bci) {
  ciBlock *cb = block_containing(bci);
  if (cb == NULL ) {
     // 当cb为NULL时，表示是第一次访问些字节码指令，需要创建一个全新的
     // 基本块，并且将bci代表的字节码指令指定为此基本块的第一条字节码指令
     ciBlock *nb = new(_arena) ciBlock(_method, _num_blocks++, bci);
     _blocks->append(nb);
     _bci_to_block[bci] = nb;
    return nb;
  } else if (cb->start_bci() == bci) {
     // 已经创建了字节码指令对应的基本块，直接返回即可
     return cb;
  } else {
     // 已经创建了一个基本块，而bci表示的字节码指令并不是这个基本块的
     // 第一个字节码指令，所以需要将这个已经创建的基本块分割为2个基本块
     return split_block_at(bci);
  }
}
ciBlock *ciMethodBlocks::split_block_at(int bci) {
  // 获取之前创建出来的基本块
  ciBlock *former_block = block_containing(bci); 
  ciBlock *new_block = new(_arena) ciBlock(_method, _num_blocks++, former_block->start_bci());
  _blocks->append(new_block);

  new_block->set_limit_bci(bci);
  former_block->set_start_bci(bci);

  // 由于之前小于等于bci-1下标索引的字节码指令可能已经映射为指向之前创建出来的基本块了，
  // 所以需要将这一部分重新映射指向为新创建出来的基本块
  for (int pos=bci-1; pos >= 0; pos--) {
    ciBlock *current_block = block_containing(pos);
    if (current_block == former_block) {
      // 更新之前的映射信息
      _bci_to_block[pos] = new_block;
    } else if (current_block == NULL) {
      continue;
    } else {
      break;
    }
  }

  // ...
  return former_block;
}

计算块中的活跃集：
void MethodLiveness::init_gen_kill() {
  for (int i=_block_count-1; i >= 0; i--) {
    _block_list[i]->compute_gen_kill(method());
  }
}
load_two()与load_one()操作的是_gen，而store_two()与store_one()操作的是_kill，这2个属性定义在MethodLiveness类中:
_gen is the set of locals used before they are defined in the range.  _kill is the set of locals defined before they are used.
这样看来，只有首次出现的、操作局部变量表中同一个索引位置的store或load指令才能被_gen或_kill记录下来。

传播活跃集:
void MethodLiveness::propagate_liveness() {

}
将_block_list中存储的基本块逆序存储到_work_list中，然后调用propagate()函数循环进行处理

标出循环相关信息:
void BlockListBuilder::mark_loops() {

}
注意对irscope->requires_phi_function()函数的调用，这会改变IRScope中_requires_phi_function属性的值。

