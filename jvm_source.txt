第1篇-关于运行时，开篇说的简单些
不过由于Java方法与C/C++函数的调用约定不同，所以并不能直接调用，需要JavaCalls::call()这个函数辅助调用
从C/C++方法中调用的一些Java方法主要有：
（1）Java主类中的main()方法；
（2）Java主类装载时，调用JavaCalls::call()函数执行checkAndLoadMain()方法；
（3）类的初始化过程中，调用JavaCalls::call()函数执行的Java类初始化方法<clinit>，可以查看JavaCalls::call_default_constructor()函数，有对<clinit>方法的调用逻辑；
（4）我们先省略main方法的执行流程（其实main方法的执行也是通过JLI_Launch先启动一个JavaMain线程，套路都是一样的），单看某个JavaThread的启动过程。
JavaThread的启动最终都要通过一个native方法java.lang.Thread#start0()完成的，这个方法经过解释器的native_entry入口，调用到了JVM_StartThread()函数。
其中的static void thread_entry(JavaThread* thread, TRAPS)函数中会调用JavaCalls::call_virtual()函数。JavaThread最终会通过JavaCalls::call_virtual()函数来调用字节码中的run()方法；
（5）在SystemDictionary::load_instance_class()这个能体现双亲委派的函数中，如果类加载器对象不为空，则会调用这个类加载器的loadClass()函数（通过call_virtual()函数来调用）来加载类。

// HotSpot VM里对JNI的CallStaticVoidMethod的实现。留意要传给Java方法的参数以C的可变长度参数传入，这个函数将其收集打包为JNI_ArgumentPusherVaArg对象
-> jni_CallStaticVoidMethod() 
 
	// 这里进一步将要传给Java的参数转换为JavaCallArguments对象传下去 
	-> jni_invoke_static() 
   
	    // 真正底层实现的开始。这个方法只是层皮，把JavaCalls::call_helper()用os::os_exception_wrapper()包装起来，目的是设置HotSpot VM的C++层面的异常处理
	    -> JavaCalls::call()
	 
	       -> JavaCalls::call_helper()
	          -> //... 检查目标方法是否为空方法，是的话直接返回
	          -> //... 检查目标方法是否“首次执行前就必须被编译”，是的话调用JIT编译器去编译目标方法
	          -> //... 获取目标方法的解释模式入口from_interpreted_entry，下面将其称为entry_point
	          -> //... 确保Java栈溢出检查机制正确启动
	          -> //... 创建一个JavaCallWrapper，用于管理JNIHandleBlock的分配与释放，以及在调用Java方法前后保存和恢复Java的frame pointer/stack pointer

	          //... StubRoutines::call_stub()返回一个指向call stub的函数指针，
	          // 紧接着调用这个call stub，传入前面获取的entry_point和要传给Java方法的参数等信息
	          -> StubRoutines::call_stub()(...) 
	             // call stub是在VM初始化时生成的。对应的代码在StubGenerator::generate_call_stub()函数中
	             -> //... 把相关寄存器的状态调整到解释器所需的状态
	             -> //... 把要传给Java方法的参数从JavaCallArguments对象解包展开到解释模式calling convention所要求的位置
	             -> //... 跳转到前面传入的entry_point，也就是目标方法的from_interpreted_entry

	                -> //... 在-Xcomp模式下，实际跳入的是i2c adapter stub，将解释模式calling convention传入的参数挪到编译模式calling convention所要求的位置
	                       -> //... 跳转到目标方法被JIT编译后的代码里，也就是跳到 nmethod 的 VEP 所指向的位置
	                            -> //... 正式开始执行目标方法被JIT编译好的代码 <- 这里就是"main()方法的真正入口"

第2篇-关于运行时的call_helper()函数
native方法的栈帧、Java解释栈帧和Java编译栈帧都会在宿主栈中分配，这些不同的栈帧都紧密的挨在一起
调用call_stub()返回的函数，需要传递8个参数。如下：
link 此变量的类型为JavaCallWrapper，这个变量对于栈展开过程非常重要，后面会详细介绍；
result_val_address 函数返回值地址；
result_type 函数返回类型；
method() 当前要执行的方法。通过此参数可以获取到Java方法所有的元数据信息，包括最重要的字节码信息，这样就可以根据字节码信息解释执行这个方法了；
entry_point HotSpot每次在调用Java函数时，必然会调用CallStub函数指针，这个函数指针的值取自_call_stub_entry，HotSpot通过_call_stub_entry指向被调用函数地址。在调用函数之前，必须要先经过entry_point，HotSpot实际是通过entry_point从method()对象上拿到Java方法对应的第1个字节码命令，这也是整个函数的调用入口；
args->parameters() 描述Java函数的入参信息；
args->size_of_parameters() 描述Java函数的入参数量；
CHECK 当前线程对象

第3篇-CallStub新栈帧的创建
static CallStub call_stub(){
	return (CallStub)( 
    	unsigned int(_call_stub_entry) );
}
_call_stub_entry的生成:
JavaMain()
InitializeJVM()
JNI_CreateJavaVM()
Threads::create_vm() 	 	
init_globals()
stubRoutines_init1()
StubRoutines::initialize1() 	
StubGenerator_generate()
StubGenerator::StubGenerator() 	 	 	
StubGenerator::generate_initial()
StubRoutines::_call_stub_entry = generate_call_stub(
        StubRoutines::_call_stub_return_address
);

第4篇-JVM终于开始调用Java主类的main()方法
空
第5篇-调用Java方法后弹出栈帧及处理返回结果
统合这一篇和前几篇文章，我们应该学习到C/C++的调用约定以及Java方法在解释执行下的调用约定

第6篇-Java方法新栈帧的创建
from_interpreted_entry通过Method::link_method函数从_entry_table读取到对应的entry进行赋值，而_entry_table的生成则通过以下调用栈:
JavaMain()
InitializeJVM()
JNI_CreateJavaVM()
Threads::create_vm()
init_globals()
interpreter_init()
TemplateInterpreter::initialize() 	
InterpreterGenerator::InterpreterGenerator()
TemplateInterpreterGenerator::generate_all()
AbstractInterpreterGenerator::generate_method_entry
address InterpreterGenerator::generate_normal_entry(bool synchronized) {

		// ...

		// entry_point函数的代码入口地址
		address entry_point = __ pc(); 		

		// 当前rbx中存储的是指向Method的指针，
		// 通过Method*找到ConstMethod*
		const	Address constMethod(rbx,Method::const_offset()); 

		// 通过Method*找到AccessFlags
		const	Address access_flags(rbx,
								Method::access_flags_offset()); 

		// 通过ConstMethod*得到parameter的大小
		const	Address size_of_parameters(
								rdx,ConstMethod::size_of_parameters_offset());

		// 通过ConstMethod*得到local变量的大小
		const	Address size_of_locals(rdx, 
									ConstMethod::size_of_locals_offset());		

		// 上面已经说明了获取各种方法元数据的计算方式，
		// 但并没有执行计算，下面会生成对应的汇编来执行计算
		// 计算ConstMethod*，保存在rdx里面
		__ movptr(rdx, constMethod); 

		// 计算parameter大小，保存在rcx里面 
		__ load_unsigned_short(rcx, size_of_parameters);	

		// rbx：保存基址；rcx：保存循环变量；
		// rdx：保存目标地址；rax：保存返回地址（下面用到）
		// 此时的各个寄存器中的值如下：
		// rbx: Method*
		// rcx: size of parameters
		// r13: 
		// sender_sp (could differ from sp+wordSize 
		// if we were called via c2i ) 即调用者的栈顶地址
		// 计算local变量的大小，保存到rdx
		__ load_unsigned_short(rdx, size_of_locals);

		// 由于局部变量表用来存储传入的参数和被调
		// 用方法的局部变量，所以rdx减去
		// rcx后就是被调用方法的局部变量可使用的大小 
		__ subl(rdx, rcx); 

		// ... 

		// 返回地址是在CallStub中保存的，如果不弹
		// 出堆栈到rax，中间会有个
		// return address使的局部变量表不是连续的，
		// 这会导致其中的局部变量计算方式不一致，所以
		// 暂时将返回地址存储到rax中
		__ pop(rax); 

		// 计算第1个参数的地址：
		// 当前栈顶地址 + 变量大小 * 8 - 一个字大小
		// 注意，因为地址保存在低地址上，而堆栈是向低
		// 地址扩展的，所以只需加n-1个
		// 变量大小就可以得到第1个参数的地址
		__ lea(r14, Address(rsp, rcx, Address::times_8, -wordSize)); 

		// 把函数的局部变量设置为0,也就是做初始化，
		// 防止之前遗留下的值影响
		// rdx：被调用方法的局部变量可使用的大小
		{
				Label exit, loop;
				__ testl(rdx, rdx);
				// 如果rdx<=0，不做任何操作
				__ jcc(Assembler::lessEqual, exit); 
				__ bind(loop);
				// 初始化局部变量
				__ push((int)	NULL_WORD); 
				__ decrementl(rdx); 
				__ jcc(Assembler::greater, loop);
				__ bind(exit);
		} 

		// 生成固定桢
		generate_fixed_frame(false); 
	
		// ... 省略统计及栈溢出等逻辑，后面会详细介绍 
		// 如果是同步方法时，还需要执行lock_method()
		// 函数，所以会影响到栈帧布局 
		if	(synchronized) {
				lock_method();
		} 

		// 跳转到目标Java方法的第一条字节码指令，
		// 并执行其对应的机器指令
        __ dispatch_next(vtos); 

		// ... 省略统计相关逻辑，后面会详细介绍 
		return	entry_point;
}

第7篇-为Java创建帧栈
void TemplateInterpreterGenerator::generate_fixed_frame(bool native_call) {
	// 把返回地址紧接着局部变量区保存
	__ push(rax); 
	// 为Java方法创建栈帧 
	__ enter(); 
	// 保存调用者的栈顶地址 
	__ push(r13); 
	// 暂时将last_sp属性的值设置为NULL_WORD 
	__ push((int)NULL_WORD);
	// 获取ConstMethod*并保存到r13中
	__ movptr(r13, Address(rbx, Method::const_offset())); 
	// 保存Java方法字节码的地址到r13中
	__ lea(r13, Address(r13, ConstMethod::codes_offset())); 
	// 保存Method*到堆栈上
	__ push(rbx);   

	// ProfileInterpreter属性的默认值为true，
	// 表示需要对解释执行的方法进行相关信息的统计
	if (ProfileInterpreter) {
		Label method_data_continue;
		// MethodData结构基础是ProfileData，
		// 记录函数运行状态下的数据
		// MethodData里面分为3个部分，
		// 一个是函数类型等运行相关统计数据，
		// 一个是参数类型运行相关统计数据，
		// 还有一个是extra扩展区保存着
		// deoptimization的相关信息
		// 获取Method中的_method_data属性的值并保存到rdx中
		__ movptr(rdx, Address(rbx, in_bytes(Method::method_data_offset())));

		__ testptr(rdx, rdx);
		__ jcc(Assembler::zero, method_data_continue);
		// 执行到这里，说明_method_data已经进行了初始化，
		// 通过MethodData来获取_data属性的值并存储到rdx中
		__ addptr(rdx, in_bytes(MethodData::data_offset()));
		__ bind(method_data_continue);
		__ push(rdx); 

	} else {
		__ push(0);
	}


	// 获取ConstMethod*存储到rdx
	__ movptr(rdx, Address(rbx, 
	    Method::const_offset()));
	// 获取ConstantPool*存储到rdx
	__ movptr(rdx, Address(rdx, 
	     ConstMethod::constants_offset())); 
	// 获取ConstantPoolCache*并存储到rdx
	__ movptr(rdx, Address(rdx, 
	     ConstantPool::cache_offset_in_bytes())); 
	// 保存ConstantPoolCache*到堆栈上
	__ push(rdx); 
	// 保存第1个参数的地址到堆栈上
	__ push(r14); 


	if (native_call) {
		// native方法调用时，不需要保存Java
		// 方法的字节码地址，因为没有字节码
		__ push(0); 
	} else {
		// 保存Java方法字节码地址到堆栈上，
		// 注意上面对r13寄存器的值进行了更改
		__ push(r13);
	}


	// 预先保留一个slot，后面有大用处
	__ push(0); 
	// 将栈底地址保存到这个slot上
	__ movptr(Address(rsp, 0), rsp); 

}
generate_fixed_frame执行后寄存器的状态:
rbx：Method*
ecx：invocation counter
r13：bcp(byte code pointer)
rdx：ConstantPool* 常量池的地址
r14：本地变量表第1个参数的地址

第8篇-dispatch_next()函数分派字节码
// 从generate_fixed_frame()函数生成
// Java方法调用栈帧的时候，
// 如果当前是第一次调用，那么r13指向
// 的是字节码的首地址，
// 即第一个字节码，此时的step参数为0
void InterpreterMacroAssembler::dispatch_next(TosState	state, int	step) { 
		load_unsigned_byte(rbx, Address(r13, step)); 
		// 在当前字节码的位置，指针向前移动step宽度，
		// 获取地址上的值，这个值是Opcode（范围1~202），
		// 存储到rbxstep的值由字节码指令
		// 和它的操作数共同决定
		// 自增r13供下一次字节码分派使用
		increment(r13, step); 

		// 返回当前栈顶状态的所有字节码入口点
		dispatch_base(state, Interpreter::dispatch_table(state));
}

void	InterpreterMacroAssembler::dispatch_base(
		TosState		state, // 表示栈顶缓存状态
		address* table,
		bool	verifyoop
) {

		// ...

		// 获取当前栈顶状态字节码转发表
		// 的地址，保存到rscratch1
		lea(rscratch1, ExternalAddress((address)table));
		// 跳转到字节码对应的入口执行机器码指令
		// address = rscratch1 + rbx * 8
		jmp(Address(rscratch1, rbx, Address::times_8));
}

dispatch_next生成的汇编:

// 在generate_fixed_frame()函数中
// 已经让%r13存储了bcp
// %ebx中存储的是字节码的Opcode，也就是操作码
movzbl 0x0(%r13),%ebx 
		
// $0x7ffff73ba4a0这个地址指向的
// 是对应state状态(out tos)下的一维数组，长度为256
movabs $0x7ffff73ba4a0,%r10	

// 注意%r10中存储的是常量，根据计算公式
// %r10+%rbx*8来获取指向存储入口地址的地址，
// 通过*(%r10+%rbx*8)获取到入口地址，
// 然后跳转到入口地址执行
jmpq *(%r10,%rbx,8)

// 参数i就是opcode, _table为9x256的数组
void DispatchTable::set_entry(
		int i, EntryPoint& entry) {
		_table[btos][i] = entry.entry(btos);
		_table[ctos][i] = entry.entry(ctos);
		_table[stos][i] = entry.entry(stos);
		_table[atos][i] = entry.entry(atos);
		_table[itos][i] = entry.entry(itos);
		_table[ltos][i] = entry.entry(ltos);
		_table[ftos][i] = entry.entry(ftos);
		_table[dtos][i] = entry.entry(dtos);
		_table[vtos][i] = entry.entry(vtos);
}
_table的一维为栈顶缓存状态，二维为Opcode，通过这2个维度能够找到一段机器指令，这就是根据当前的栈顶缓存状态定位到的字节码需要执行的机器指令片段

第9篇-字节码指令的定义
Bytecodes::initialize()
def(_nop , "nop"                 , "b"    , NULL    , T_VOID , 0, false);
bytecode name就是字节码名称；
wide表示字节码前面是否可以加wild，如果可以，则值为"wbii"；
result tp表示指令执行后的结果类型，如为T_ILLEGAL时，表示只参考当前字节码无法决定执行结果的类型，如_invokevirtual方法调用指令，结果类型应该为方法返回类型，但是此时只参数这个调用方法的字节码指令是无法决定的；
stk表示对表达式栈深度的影响，如_nop指令不执行任何操作，所以对表达式栈的深度无影响，stk的值为0；当用_iconst_0向栈中压入0时，栈的深度增加1，所以stk的值为1。当为_lconst_0时，栈的深度会增加2；当为_lstore_0时，栈的深度会减少2；
traps表示can_trap，这个比较重要，在后面会详细介绍； ???
format，这个属性能表达2个意思，首先能表达字节码的格式，另外还能表示字节码的长度。
format详解:
b：表示字节码指令是非可变长度的，所以对于tableswitch、lookupswitch这种可变长度的指令来说，format字符串中不会含有b字符 
c：操作数为有符号的常量，如bipush指令将byte带符号扩展为一个int类型的值，然后将这个值入栈到操作数栈中 
i：操作数为无符号的本地变量表索引值，如iload指令从局部变量表加载一个int类型的值到操作数栈中 
j：操作数为常量池缓存的索引，注意常量池缓存索引不同与常量池索引，关于常量池索引，在《深入剖析Java虚拟机：源码剖析与实例详解》基础卷中详细介绍过，这里不再介绍 
k：操作数为无符号的常量池索引，如ldc指令将从运行时常量池中提取数据并压入操作数栈，所以格式为"bk" 
o：操作数为分支偏移，如ifeq表示整数与零比较，如果整数为0，则比较结果为真，将操作数看为分支偏移量进行跳转，所以格式为”boo“ 
_：可直接忽略
w：可用来扩展局部变量表索引的字节码，这些字节码有iload、fload等，所以wild的值为"wbii" 

第10篇-初始化模板表
void TemplateInterpreter::initialize() {
 	if 	(_code != NULL) 
		return;
 	 	
 	// 抽象解释器AbstractInterpreter的初始化，
 	// AbstractInterpreter是基于汇编模型的解释器的共同基类，
 	// 定义了解释器和解释器生成器的抽象接口
 	AbstractInterpreter::initialize(); ???
 	 	
 	// 模板表TemplateTable的初始化，模板表TemplateTable保存了各个字节码的模板
 	TemplateTable::initialize();
 	 	
 	// generate interpreter
 	{
 	 	ResourceMark rm;
 	 	int 	code_size = InterpreterCodeSize;
 	 	// CodeCache的Stub队列StubQueue的初始化
 	 	_code = new 	StubQueue(new 	InterpreterCodeletInterface, code_size, NULL,"Interpreter");
 	 	// 实例化模板解释器生成器对象TemplateInterpreterGenerator
 	 	InterpreterGenerator g(_code);
 	}
 	 	
 	// 初始化字节分发表
 	_active_table = _normal_table;
}
TemplateTable::initialize()
def(Bytecodes::_invokevirtual, ubcp|disp|clvm|____, vtos, vtos, invokevirtual, f2_byte);
标志位ubcp|disp|clvm|iswd详解:
uses_bcp_bit，标志需要使用字节码指针。表示生成的模板代码中是否需要使用指向字节码指令的指针，其实也就是说是否需要读取字节码指令的操作数，所以含有操作数的指令大部分都需要bcp，但是有一些是不需要的，如monitorenter与monitorexit等，这些的操作数都在表达式栈中，表达式栈顶就是其操作数，并不需要从Class文件中读取，所以不需要bcp；
does_dispatch_bit，标志表示自己是否含有控制流转发逻辑，如tableswitch、lookupswitch、invokevirtual、ireturn等字节码指令，本身就需要进行控制流转发；
calls_vm_bit，标志是否需要调用JVM函数，在调用TemplateTable::call_VM()函数时都会判断是否有这个标志，通常方法调用JVM函数时都会通过调用TemplateTable::call_VM()函数来间接完成调用。JVM函数就是用C++写的函数；
wide_bit，标志是否是wide指令（使用附加字节扩展全局变量索引）
_tos_in与_tos_out：
表示模板执行前与模板执行后的TosState(TopOfStack state: 栈顶的数据类型)
如iload指令，执行之前栈顶状态为vtos，表示并不会使用栈顶的数据，所以如果程序为了提高执行效率将上一次执行的结果缓存到了寄存器中，那么此时就应该在执行iload指令之前将这个寄存器的值压入栈顶。iload指令执行之后的栈顶状态为itos，因为iload是向操作数栈中压入一个整数，所以此时的栈顶状态为int类型，那么这个值可以缓存到寄存器中，假设下一个指令为ireturn，那么栈顶之前与之后的状态分别为itos和itos，那么可直接将缓存在寄存器中的int类型返回即可，不需要做任何和操作数栈相关的操作。

第11篇-初始化StubQueue
StubQueue是用来保存生成的本地代码的Stub队列，队列每一个元素对应一个InterpreterCodelet对象，InterpreterCodelet对象继承自抽象基类Stub，包含了字节码对应的本地代码以及一些调试和输出信息。
每个字节码都有一个InterpreterCodelet实例，所以在解释执行时，则执行的就是由InterpreterCodelet实例代表的机器指令片段。

第12篇-认识CodeletMark
InterpreterCodelet依赖CodeletMark完成自动创建和初始化。CodeletMark继承自ResourceMark，允许自动析构，执行的主要操作就是，会按照InterpreterCodelet中存储的实际机器指令片段分配内存并提交。

第13篇-通过InterpreterCodelet存储机器指令片段
空

第14篇-生成重要的例程
error exits								当方法出现时会调用这个例程，进行出错时程序退出
bytecode tracing support				配置命令-XX:+TraceBytecodes后，进行字节码追踪
return entry points 					函数返回入口
invoke return entry points 				对于某些invoke字节码调用指令来说，需要一些特殊的返回入口
earlyret entry points 					VMTI的EarlyReturn入口
deoptimization entry points 	 		从"逆优化"调用返回的入口
result handlers for native calls 		本地方法调用返回值处理handlers
continuation entry points 				continuation入口
safepoint entry points 					safepoint入口，当执行字节码时，如果要求解释执行进入安全点，则会执行safepoint入口指定的机器指令片段
exception handling 						异常处理例程
throw exception entrypoints 			抛出异常的入口
all non-native method kinds 			非本地方法的入口
all native method kinds					本地方法的入口
Bytecodes 								字节码的入口

字节码入口:
TemplateInterpreterGenerator::generate_all()
TemplateInterpreterGenerator::set_entry_points_for_all_bytes
void TemplateInterpreterGenerator::set_short_entry_points(Template* t, address& bep, address& cep, address& sep, address& aep, address& iep, address& lep, address& fep, address& dep, address& vep) {
  assert(t->is_valid(), "template must exist");
  switch (t->tos_in()) {
    case btos:
    case ztos:
    case ctos:
    case stos:
      ShouldNotReachHere();  // btos/ctos/stos should use itos.
      break;
    //vep: void entry point(当tos为vtos时的入口,从栈顶pop到寄存器进行缓存以满足atos)
    //aep: object entry point(当tos为atos时的入口)
    case atos: vep = __ pc(); __ pop(atos); aep = __ pc(); generate_and_dispatch(t); break;
    case itos: vep = __ pc(); __ pop(itos); iep = __ pc(); generate_and_dispatch(t); break;
    case ltos: vep = __ pc(); __ pop(ltos); lep = __ pc(); generate_and_dispatch(t); break;
    case ftos: vep = __ pc(); __ pop(ftos); fep = __ pc(); generate_and_dispatch(t); break;
    case dtos: vep = __ pc(); __ pop(dtos); dep = __ pc(); generate_and_dispatch(t); break;
    case vtos: set_vtos_entry_points(t, bep, cep, sep, aep, iep, lep, fep, dep, vep);     break;
    default  : ShouldNotReachHere();                                                 break;
  }
}
void TemplateInterpreterGenerator::generate_and_dispatch(Template* t, TosState tos_out) {
 	// 生成当前字节码指令对应的机器指令片段
 	t->generate(_masm);

 	if 	(t->does_dispatch()) {
 	 	// asserts
 	} else 	{
 	 	// 生成分发到下一个字节码指令的逻辑 InterpreterMacroAssembler::dispatch_next
 	 	__ dispatch_epilog(tos_out, step);
 	}
}
上一个字节码指令的执行结果和下一个指令执行之前要求的栈顶缓存状态共同决定了指令的入口，也就是说一个指令其实有多个入口

15~18 跳过
第15章-解释器及解释器生成器
第16章-汇编器
第17章-x86-64寄存器
第18章-x86指令集之常用指令
第19篇-加载与存储指令（1）
字节码采用大端存储，所以需要通过bswap和位移计算变换为小端存储，参考sipush的汇编
第20篇-加载与存储指令之ldc与_fast_aldc指令
ldc指令可以加载String、方法类型或方法句柄的符号引用，但是如果要加载String、方法类型或方法句柄的符号引用，则会在类连接过程中重写ldc字节码指令为虚拟机内部使用的字节码指令_fast_aldc:
// TemplateTable::ldc(bool wide)
// ldc指定的格式为ldc index，index为一个字节
0x00007fffe1028530: movzbl 0x1(%r13),%ebx // 加载index到%ebx

// %rcx指向缓存池首地址、%rax指向类型数组_tags首地址
0x00007fffe1028535: mov -0x18(%rbp),%rcx
0x00007fffe1028539: mov 0x10(%rcx),%rcx
0x00007fffe102853d: mov 0x8(%rcx),%rcx
0x00007fffe1028541: mov 0x10(%rcx),%rax

// 从_tags数组获取操作数类型并存储到%edx中
0x00007fffe1028545: movzbl 0x4(%rax,%rbx,1),%edx

// $0x64代表JVM_CONSTANT_UnresolvedClass，比较，如果类还没有链接，则直接跳转到call_ldc
0x00007fffe102854a: cmp $0x64,%edx
0x00007fffe102854d: je 0x00007fffe102855d   // call_ldc

// $0x67代表JVM_CONSTANT_UnresolvedClassInError，也就是如果类在链接过程中出现错误，则跳转到call_ldc
0x00007fffe102854f: cmp $0x67,%edx
0x00007fffe1028552: je 0x00007fffe102855d  // call_ldc

// $0x7代表JVM_CONSTANT_Class，表示如果类已经进行了连接，则跳转到notClass
0x00007fffe1028554: cmp $0x7,%edx
0x00007fffe1028557: jne 0x00007fffe10287c0 // notClass

// 调用TemplateTable::call_VM()函数
// 类在没有连接或连接过程中出错，则执行如下的汇编代码
// -- call_ldc --
// 将wide的值移到%esi寄存器，为后续
// 调用InterpreterRuntime::ldc(JavaThread* thread, bool wide)函数准备第2个参数
0x00007fffe102855d: mov $0x0,%esi
// 调用MacroAssembler::call_VM()函数，通过此函数来调用HotSpot VM中用
// C++编写的函数，通过这个C++编写的函数来调用InterpreterRuntime::ldc()函数
0x00007fffe1017542: callq 0x00007fffe101754c
0x00007fffe1017547: jmpq 0x00007fffe10287ba // 跳转到E1
// 调用MacroAssembler::call_VM_helper()函数
// 将栈顶存储的返回地址设置到%rax中，也就是将存储地址0x00007fffe1017547
// 的栈的slot地址设置到%rax中
0x00007fffe101754c: lea 0x8(%rsp),%rax

// 调用InterpreterMacroAssembler::call_VM_base()函数存储bcp到栈中特定位置
0x00007fffe1017551: mov %r13,-0x38(%rbp)

// 调用MacroAssembler::call_VM_base()函数
// 将r15中的值移动到rdi寄存器中，也就是为函数调用准备第一个参数
0x00007fffe1017555: mov %r15,%rdi
// 只有解释器才必须要设置fp
// 将last_java_fp保存到JavaThread类的last_java_fp属性中
0x00007fffe1017558: mov %rbp,0x200(%r15)
// 将last_java_sp保存到JavaThread类的last_java_sp属性中
0x00007fffe101755f: mov %rax,0x1f0(%r15)

// 调用MacroAssembler::call_VM_leaf_base()函数
// 检查对齐
// %esp对齐的操作，跳转到 L
0x00007fffe1017566: test $0xf,%esp
0x00007fffe101756c: je 0x00007fffe1017584
// %esp没有对齐时的操作
0x00007fffe1017572: sub $0x8,%rsp
// 调用函数，也就是调用InterpreterRuntime::ldc()函数
0x00007fffe1017576: callq 0x00007ffff66a22a2
0x00007fffe101757b: add $0x8,%rsp
// 跳转到E2
0x00007fffe101757f: jmpq 0x00007fffe1017589
// -- L --
// %esp对齐的操作
// 调用函数，也就是调用InterpreterRuntime::ldc()函数
0x00007fffe1017584: callq 0x00007ffff66a22a2

// 结束调用MacroAssembler::call_VM_leaf_base()函数

// -- E2 --
// 重置JavaThread::last_java_sp与JavaThread::last_java_fp属性的值
0x00007fffe1017589: movabs $0x0,%r10
0x00007fffe1017593: mov %r10,0x1f0(%r15)
0x00007fffe101759a: movabs $0x0,%r10
0x00007fffe10175a4: mov %r10,0x200(%r15)

// check for pending exceptions (java_thread is set upon return)
0x00007fffe10175ab: cmpq $0x0,0x8(%r15)
// 如果没有异常则直接跳转到ok
0x00007fffe10175b3: je 0x00007fffe10175be
// 如果有异常则跳转到StubRoutines::forward_exception_entry()获取的例程入口
0x00007fffe10175b9: jmpq 0x00007fffe1000420

// -- ok --
// 将JavaThread::vm_result属性中的值存储到%rax寄存器中并清空vm_result属性的值
0x00007fffe10175be: mov 0x250(%r15),%rax
0x00007fffe10175c5: movabs $0x0,%r10
0x00007fffe10175cf: mov %r10,0x250(%r15)

// 结束调用MacroAssembler::call_VM_base()函数

// 恢复bcp与locals
0x00007fffe10175d6: mov -0x38(%rbp),%r13
0x00007fffe10175da: mov -0x30(%rbp),%r14

// 结束调用MacroAssembler::call_VM_helper()函数

0x00007fffe10175de: retq
// 结束调用MacroAssembler::call_VM()函数

整体调用栈:
TemplateTable::call_VM()
MacroAssembler::call_VM()
    MacroAssembler::call_VM_helper()
       InterpreterMacroAssembler::call_VM_base()
           MacroAssembler::call_VM_base()
                MacroAssembler::call_VM_leaf_base()
最重要的就是在MacroAssembler::call_VM_base()函数中保存rsp、rbp的值到JavaThread::last_java_sp与JavaThread::last_java_fp属性中(避免rsp和rbp被破坏，同理r13和r14也被保护起来)，
然后通过MacroAssembler::call_VM_leaf_base()函数生成的汇编代码来调用C++编写的InterpreterRuntime::ldc()函数

// -- E1 --
0x00007fffe10287ba: push %rax // 将调用的结果存储到表达式中
0x00007fffe10287bb: jmpq 0x00007fffe102885e // 跳转到Done

// -- notClass --
// $0x4表示JVM_CONSTANT_Float
0x00007fffe10287c0: cmp $0x4,%edx
0x00007fffe10287c3: jne 0x00007fffe10287d9 // 跳到notFloat
// 当ldc字节码指令加载的数为float时执行如下汇编代码
0x00007fffe10287c5: vmovss 0x58(%rcx,%rbx,8),%xmm0
0x00007fffe10287cb: sub $0x8,%rsp
0x00007fffe10287cf: vmovss %xmm0,(%rsp)
0x00007fffe10287d4: jmpq 0x00007fffe102885e // 跳转到Done

// -- notFloat --
// 当ldc字节码指令加载的为非float，也就是int类型数据时通过push加入表达式栈
0x00007fffe1028859: mov 0x58(%rcx,%rbx,8),%eax
0x00007fffe102885d: push %rax

// TemplateTable::fast_aldc(bool wide)
0x00007fffe10243d0: movzbl 0x1(%r13),%edx

// 调用InterpreterMacroAssembler::load_resolved_reference_at_index()函数生成

// shl表示逻辑左移，相当于乘4,因为ConstantPoolCacheEntry的大小为4个字
0x00007fffe10243d5: shl $0x2,%edx

// 获取Method*
0x00007fffe10243d8: mov -0x18(%rbp),%rax
// 获取ConstMethod*
0x00007fffe10243dc: mov 0x10(%rax),%rax
// 获取ConstantPool*
0x00007fffe10243e0: mov 0x8(%rax),%rax
// 获取ConstantPool::_resolved_references属性的值，这个值是一个指向对象数组的指针
0x00007fffe10243e4: mov 0x30(%rax),%rax

// JNIHandles::resolve(obj)
0x00007fffe10243e8: mov (%rax),%rax

// 从_resolved_references数组指定的下标索引处获取oop，先进行索引偏移
0x00007fffe10243eb: add %rdx,%rax

// 要在%rax上加0x10，是因为数组对象的头大小为2个字，加上后%rax就指向了oop
0x00007fffe10243ee: mov 0x10(%rax),%eax

ConstantPool::_resolved_references的调用栈(自下而上):
ConstantPool::initialize_resolved_references()  constantPool.cpp     
Rewriter::make_constant_pool_cache()  rewriter.cpp  
Rewriter::Rewriter()  rewriter.cpp
Rewriter::rewrite()  rewriter.cpp
InstanceKlass::rewrite_class()  instanceKlass.cpp  
InstanceKlass::link_class_impl()  instanceKlass.cpp

// %eax中存储着表示目标的oop
0x00007fffe1024479: test %eax,%eax
// 如果已经获取到了oop，则跳转到resolved
0x00007fffe102447b: jne 0x00007fffe1024481

// 没有获取到oop，需要进行连接操作，0xe5是_fast_aldc的Opcode
0x00007fffe1024481: mov $0xe5,%edx

// 省略通过call_VM调用InterpreterRuntime::resolve_ldc() 进行解析

string类型常量的解析调用栈(自下而上):
ConstantPool::string_at_put()   constantPool.hpp
ConstantPool::string_at_impl()  constantPool.cpp
ConstantPool::resolve_constant_at_impl()     constantPool.cpp  
ConstantPool::resolve_cached_constant_at()   constantPool.hpp  
Bytecode_loadconstant::resolve_constant()    bytecode.cpp  
InterpreterRuntime::resolve_ldc()            interpreterRuntime.cpp

string_at_put会根据表示字符串的Symbol实例创建出表示字符串的oop, 然后存储到ConstantPool::_resolved_references属性中，
再次解析时会优先从_resolved_references属性中获取，保证字符串常量在jvm的唯一性

第21篇-加载与存储指令之iload、_fast_iload等
// TemplateTable::iload()
// 将%ebx指向下一条字节码指令的首地址
0x00007fffe1028d30: movzbl 0x2(%r13),%ebx
// $0x15为_iload指令的操作码值
0x00007fffe1028d35: cmp $0x15,%ebx
// 当下一条指令为iload时，直接跳转到done
0x00007fffe1028d38: je 0x00007fffe1028deb // done

// 0xdf为_fast_iload指令的操作码值
0x00007fffe1028d3e: cmp $0xdf,%ebx
// 将_fast_iload2指令移动到%ecx
0x00007fffe1028d44: mov $0xe0,%ecx
0x00007fffe1028d49: je 0x00007fffe1028d5a // rewrite

// 0x34为_caload指令的操作码
// _caload指令表示从数组中加载一个char类型数据到操作数栈
0x00007fffe1028d4b: cmp $0x34,%ebx
// 将_fast_icaload移动到%ecx中
0x00007fffe1028d4e: mov $0xe1,%ecx
0x00007fffe1028d53: je 0x00007fffe1028d5a // rewrite

// 将_fast_iload移动到%ecx中
0x00007fffe1028d55: mov $0xdf,%ecx

// -- rewrite --

// 调用patch_bytecode()函数
// 重写为fast版本，因为%cl中存储的是字节码的fast版本，%ecx的8位叫%cl
0x00007fffe1028de7: mov %cl,0x0(%r13)

// -- done --

// 获取字节码指令的操作数，这个操作数为本地变量表的索引
0x00007fffe1028deb: movzbl 0x1(%r13),%ebx
0x00007fffe1028df0: neg %rbx
// 通过本地变量表索引从本地变量表中加载值到%eax中，
// %eax中存储的就是栈顶缓存值，所以不需要压入栈内
0x00007fffe1028df3: mov (%r14,%rbx,8),%eax
 cur        next      rewrite
iload ->    iload
      ->    fast_iload   ->  fast_iload2
      ->    其他          ->  fast_iload

第22篇-字节码运算指令
空白
第23篇-字节码类型转换指令
空白
第24篇-对象操作指令之getstatic
ConstantPoolCacheEntry结构:
              8     8      16
_indices    [ b2 | b1 |  index  ] b2: put操作码  b1: get操作码  index: 原常量池索引
_f1         [   metadata ptr    ] 字段拥有者 metadata ptr (method or klass)
_f2         [   offset          ] 以字节为单位的字段偏移(在类定义中的偏移)
_flags      [tos|0|F=1|0|0|0|f|v|0 |0000|field_index] (for field entries) field_index 字段索引(在class文件中的slot值)
bit length  [ 4 |1| 1 |1|1|1|1|1|1 |-4--|--8--|--8--]
_flags      [tos|0|F=0|M|A|I|f|0|vf|0000|00000|psize] (for method entries) psize 参数的大小
flag说明: f: 1为final; v: 1为volatile; vf: virtual but final tos栈顶缓存: 字段类型对应的TosState枚举值; 操作码Opcode: 标识是否resolved
参考ConstantPoolCacheEntry::set_field

void TemplateTable::getstatic(int byte_no) {
  getfield_or_static(byte_no, true); // getstatic的byte_no值为1
}
// TemplateTable::getfield_or_static()
// 获取ConstantPoolCache中ConstantPoolCacheEntry的index
0x00007fffe101fd10: movzwl 0x1(%r13),%edx
// 从栈中获取ConstantPoolCache的首地址
0x00007fffe101fd15: mov -0x28(%rbp),%rcx

// 左移2位是因为ConstantPoolCacheEntry的内存占用是4个指针大小
0x00007fffe101fd19: shl $0x2,%edx
// 获取ConstantPoolCacheEntry[_indices,_f1,_f2,_flags]中的_indices
// 因为ConstantPoolCache的大小为16字节，%rcx+0x10定位到第一个ConstantPoolCacheEntry的开始位置
// %rdx*8算出来的是相对于第一个ConstantPoolCacheEntry的字节偏移
0x00007fffe101fd1c: mov 0x10(%rcx,%rdx,8),%ebx
// _indices向右移动16位后获取get bytecode与put bytecode
0x00007fffe101fd20: shr $0x10,%ebx
// 获取get bytecode字段的值
0x00007fffe101fd23: and $0xff,%ebx
// 0xb2是getstatic指令的Opcode，比较值，如果相等就说明已经连接，跳转到resolved
0x00007fffe101fd29: cmp $0xb2,%ebx
0x00007fffe101fd2f: je 0x00007fffe101fdce

// 将getstatic字节码的Opcode存储到%ebx中
0x00007fffe101fd35: mov $0xb2,%ebx

// 省略通过调用MacroAssembler::call_VM()函数来执行InterpreterRuntime::resolve_get_put()函数的汇编代码
// InterpreterRuntime::resolve_get_put()函数会填充常量池缓存中ConstantPoolCacheEntry信息
// InterpreterRuntime::resolve_get_put调用get_index_u2_cpcache()函数从当前方法对应的栈帧中获取bcp，然后通过bcp来获取字节码指令的操作数，也就是常量池索引，
// 得到常量池索引后调用LinkResolver::resolve_field_access()函数可能会连接类和字段(调用resolve_klass()连接类，调用resolve_field()连接字段)，
// 然后将查询到的字段相关信息存储到fieldDescriptor中的fd字段，同时填充ConstantPoolCacheEntry信息

// 将ConstantPoolCacheEntry的索引存储么%edx
0x00007fffe101fdc2: movzwl 0x1(%r13),%edx
// 将ConstantPoolCache的首地址存储到%rcx
0x00007fffe101fdc7: mov -0x28(%rbp),%rcx
// 获取对应的ConstantPoolCacheEntry对应的索引
0x00007fffe101fdcb: shl $0x2,%edx

// --resolved --

// 获取[_indices,_f1,_f2,_flags]中的_f2，
// _f2中保存的是字段在java.lang.Class实例中的字节偏移，通过此偏移就可获取此字段存储在java.lang.Class实例的值
0x00007fffe101fdce: mov 0x20(%rcx,%rdx,8),%rbx
// 获取[_indices,_f1,_f2,_flags]中的_flags 
0x00007fffe101fdd3: mov 0x28(%rcx,%rdx,8),%eax
// 获取[_indices,_f1,_f2,_flags]中的_f1保存了字段拥有者，也就是java.lang.Class对象
0x00007fffe101fdd7: mov 0x18(%rcx,%rdx,8),%rcx

// 从_f1中获取_java_mirror属性的值
0x00007fffe101fddc: mov 0x70(%rcx),%rcx
// 将_flags向右移动28位，剩下TosState
0x00007fffe101fde0: shr $0x1c,%eax
0x00007fffe101fde3: and $0xf,%eax
// 如果不相等，说明TosState的值不为0，则跳转到notByte
0x00007fffe101fde6: jne 0x00007fffe101fdf6

// btos
// btos的编号为0,代码执行到这里时，可能栈顶缓存要求是btos
// %rcx中存储的是_java_mirror，%rbx中存储的是_f2，静态变量存储在_java_mirror中
0x00007fffe101fdec: movsbl (%rcx,%rbx,1),%eax
0x00007fffe101fdf0: push %rax
// 跳转到Done
0x00007fffe101fdf1: jmpq 0x00007fffe101ff0c

// -- notByte --
// %eax中存储的是TosState，如果不为atos，则跳转到notObj
0x00007fffe101fdf6: cmp $0x7,%eax
0x00007fffe101fdf9: jne 0x00007fffe101fe90

// 省略其他tos对应的汇编代码

// Done
0x00007fffe101ff0c: movzbl 0x3(%r13),%ebx
0x00007fffe101ff11: add    $0x3,%r13
0x00007fffe101ff15: movabs $0x10b873670,%r10
0x00007fffe101ff1f: jmpq   *(%r10,%rbx,8)

第25篇-对象操作指令之getfield
// TemplateTable::getfield_or_static()
// 省略前面汇编代码，参考getstatic
---- resolved ---- 
 
// 获取[_indices,_f1,_f2,_flags]中的_f2，_f2中保存的是字段在oop实例中的字节偏移，通过此偏移就可获取此字段存储在oop中的值
0x00007fffe102038e: mov 0x20(%rcx,%rdx,8),%rbx
 
// 获取[_indices,_f1,_f2,_flags]中的_flags 
0x00007fffe1020393: mov 0x28(%rcx,%rdx,8),%eax
 
// 将栈中的objectref对象弹出到%rcx中
0x00007fffe1020397: pop %rcx
 
// provoke OS NULL exception if reg = NULL by
// accessing M[reg] w/o changing any (non-CC) registers
// NOTE: cmpl is plenty here to provoke a segv
0x00007fffe1020398: cmp (%rcx),%rax
 
// 将_flags向右移动28位，剩下TosState
0x00007fffe102039b: shr $0x1c,%eax
0x00007fffe102039e: and $0xf,%eax
// 如果不相等，说明TosState的值不为0，则跳转到notByte
0x00007fffe10203a1: jne 0x00007fffe10203ba
 
// btos
 
// btos的编号为0,代码执行到这里时，可能栈顶缓存要求是btos
// %rcx中存储的是objectref，%rbx中存储的是_f2，获取字段对应的值存储到%rax中
0x00007fffe10203a7: movsbl (%rcx,%rbx,1),%eax
0x00007fffe10203ab: push %rax
 
// 对字节码指令进行重写，将Bytecodes::_fast_bgetfield的Opcode存储到%ecx中
0x00007fffe10203ac: mov $0xcc,%ecx
// 将Bytecodes::_fast_bgetfield的Opcode更新到字节码指令的操作码
0x00007fffe10203b1: mov %cl,0x0(%r13)
// 跳转到---- Done ----
0x00007fffe10203b5: jmpq 0x00007fffe102050f
---- notByte ----
0x00007fffe10203ba: cmp $0x7,%eax
0x00007fffe10203bd: jne 0x00007fffe102045d  // 跳转到notObj

// 省略其他tos对应的汇编代码

def(_fast_agetfield , "fast_agetfield"      , "bJJ"  , NULL    , T_OBJECT , 0, true , _getfield );
以_fast_agetfield内部定义的字节码指令为例为来，生成函数为TemplateTable::fast_accessfield()函数，汇编代码如下：
0x00007fffe101e4e1: movzwl 0x1(%r13),%ebx
0x00007fffe101e4e6: mov -0x28(%rbp),%rcx
0x00007fffe101e4ea: shl $0x2,%ebx
// 获取ConstantPoolCacheEntry[_indices,_f1,_f2,_flags]中的_f2
0x00007fffe101e4ed: mov 0x20(%rcx,%rbx,8),%rbx
 
// 检查空异常
0x00007fffe101e4f2: cmp (%rax),%rax
// %rax中存储的是objectref，也就是要从这个实例中获取字段的值，通过偏移%rbx后就
// 能获取到偏移的值，然后加载到%eax
0x00007fffe101e4f5: mov (%rax,%rbx,1),%eax

第26篇-对象操作指令之putstatic
void TemplateTable::putfield(int byte_no) {
  putfield_or_static(byte_no, false);
}
// TemplateTable::resolve_cache_and_index()
// 省略前面汇编代码，参考getstatic
// ---- resolved ----
 
// 执行如下代码时，表示字段已经连接完成
0x00007fffe102004e: mov 0x20(%rcx,%rdx,8),%rbx
0x00007fffe1020053: mov 0x28(%rcx,%rdx,8),%eax
0x00007fffe1020057: mov 0x18(%rcx,%rdx,8),%rcx
0x00007fffe102005c: mov 0x70(%rcx),%rcx
0x00007fffe1020060: mov %eax,%edx
// 将_flags向右移动21位，判断是否有volatile关键字
0x00007fffe1020062: shr $0x15,%edx
0x00007fffe1020065: and $0x1,%edx
// 将_flags向右移动28位，剩下TosState
0x00007fffe1020068: shr $0x1c,%eax
 
// 如果不为btos，则跳转到notByte
0x00007fffe102006b: and $0xf,%eax
0x00007fffe102006e: jne 0x00007fffe1020083
 
// btos
 
// 将栈顶的值存储到%eax中，这个值会写入到对应的字段中
0x00007fffe1020074: mov (%rsp),%eax
0x00007fffe1020077: add $0x8,%rsp
// %rcx为_java_mirror，%rbx为_f2，表示域在类中的偏移
0x00007fffe102007b: mov %al,(%rcx,%rbx,1)
0x00007fffe102007e: jmpq 0x00007fffe10201be // 跳转到Done
// -- notByte --
// 如果不为atos，则跳转到notObj
0x00007fffe1020083: cmp $0x7,%eax
0x00007fffe1020086: jne 0x00007fffe1020130

// atos
// 将栈顶的值弹出到%rax中，这个值将用来更新对应字段的值
0x00007fffe102008c: pop %rax
// ...
// 将值更新到对应的字段上
0x00007fffe1020115: mov %eax,(%rcx,%rbx,1)
// 其中的0x9是CardTableModRefBS::card_shift，shr表示逻辑右移，由于%rcx指向的是
// java.lang.Class实例的首地址，向右移后%rcx就算出了卡表的索引
0x00007fffe1020118: shr $0x9,%rcx
// 地址常量$0x7fffe07ff000表示卡表的基地址
0x00007fffe102011c: movabs $0x7fffe07ff000,%r10
// 将对应的卡表项标记为脏，其中常量0x0就表示是脏卡
0x00007fffe1020126: movb $0x0,(%r10,%rcx,1)
0x00007fffe102012b: jmpq 0x00007fffe10201be // 跳转到Done

// 省略其他tos对应的汇编代码

// ---- Done ----

0x00007fffe10201be: test %edx,%edx
0x00007fffe10201c0: je 0x00007fffe10201cb
0x00007fffe10201c6: lock addl $0x0,(%rsp)

// ---- notVolatile ----
需要注意两点:
（1）更新引用字段时，通过屏障将对应的卡表项标记为脏，这样可在GC过程中扫描脏卡就可将活跃对象标记出来而不会造成遗漏；
（2）当字段有volatile关键字修饰时，需要填写lock指令前缀;
    Intel手册对 lock 前缀的说明如下：
        确保被修饰指令执行的原子性；(锁定特定内存地址,阻止其他的系统总线读取或修改这个内存地址)
        禁止该指令与前面和后面的读写指令重排序；
        指令执行完后把写缓冲区的所有数据刷新到内存中（这样这个指令之前的其他修改对所有处理器可见）

第27篇-操作数栈管理指令
空白
第28篇-控制转移指令
TemplateTable::_goto()
// -XX:-ProfileInterpreter可排除生成一些不必要的统计指令
goto生成的指令其实很多，因为goto指令是一个分支指令，其中会做一些性能统计以辅助进行编译优化，而且goto如果是在循环中的话，还可能会涉及到栈上替换的技术

第29篇-调用Java主类的main()方法
JavaMain()
    LoadMainClass()
    GetStaticMethodlD()
    CallStaticVoidMethod()

第30篇-解释执行main()方法小实例
空白
第31篇-方法调用指令之invokevirtual
