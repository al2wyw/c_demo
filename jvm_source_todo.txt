内存分配和回收，new指令(在基础篇)
synchronized锁和monitor指令

自研备注:
锁机制
OopMark  偏向(UseBiasedLocking太复杂)
BasicObjectLock 轻量级
ObjectMonitor  重量级(包含自旋)

异常机制
athrow
throw xxx exception entry from bytecode asm
asm inst: test/comp SIGSEGV (只有这里用到了信号)

xxx exception handler(throw xxx exception entry) => create_exception, jump _throw_exception_entry
                                                 => throw_exception
InterpreterRuntime::create_exception => thread->set_vm_result
InterpreterRuntime::throw_exception => THROW => thread->set_pending_exception (call_VM_base check pending exception and jump forward_exception_entry)
athrow => jump _throw_exception_entry
_throw_exception_entry => jump return of exception_handler_for_exception => the bci address of exception handler table in current java method
                                                                         => _remove_activation_entry => jump return of exception_handler_for_return_address => _rethrow_exception_entry (include _throw_exception_entry asm code)
StubRoutines::forward_exception_entry => jump return of SharedRuntime::exception_handler_for_return_address
JVM_handle_linux_signal => throw xxx exception entry
InterpreterRuntime::throw_pending_exception do nothing

安全点机制
解析执行进入安全点: InterpreterRuntime::at_safepoint 后续是jvmti的逻辑(JvmtiExport::post_single_step把线程加入到待暂停的列表中，最终会调用JvmtiEnv::SuspendThread函数)
编译执行进入安全点: JVM_handle_linux_signal => SharedRuntime::get_poll_stub => SharedRuntime::polling_page_return_handler_blob()->entry_point()
native执行进入安全点: native方法执行完毕后检查是否要进入安全点 => transition_from_native => JavaThread::check_safepoint_and_suspend_for_native_trans()

memory order机制
four primitive memory barrier operations:
Load1(s); LoadLoad; Load2: Loads before Load1 may *not* float below Load2
Store1(s); StoreStore; Store2: Stores before Store1 may *not* float below Store2
Load1(s); LoadStore; Store2: Loads before Load1 may *not* float below Store2
Store1(s); StoreLoad; Load2: Stores before Store1 may *not* float below Load2

|     memory accesses      | ^
|------- release  ---------| |  StoreStore
      memory accesses -------|
|------- acquire  ---------| |  LoadLoad/LoadStore
|     memory accesses      | V
fence = release + acquire       StoreLoad
load_acquire = acquire + read variable; release_store = release + write variable; store_fence = fence + write variable
why StoreStore is release and LoadLoad/LoadStore is acquire:(from java并发编程的艺术)
normal r/w StoreStore volatile w StoreLoad
volatile r LoadLoad LoadStore normal r/w
jdk15的StoreStore、LoadLoad、LoadStore、release、acquire全部变成 __asm__ volatile ("" : : : "memory"); (编译器屏障)

模版解释执行 volatile for x86:(参考cpu架构允许的重排序)
putField:
// volatile_barrier(LoadStore|StoreStore) no need for x86
put value to field
volatile_barrier(StoreLoad|StoreStore)
getField:
get value from field
// volatile_barrier((LoadLoad |LoadStore) no need for x86

volatile_barrier:
if os::is_MP() {if StoreLoad { lock addl $0x0,(%rsp);}} //只有StoreLoad有额外操作

内存分配及回收:
卡表、偏移表、写屏障(内存写入拦截器，例如更新卡表为脏)

类初始化内存分配
ClassFileParser::parseClassFile ->  InstanceKlass::allocate_instance_klass
                                    java_lang_Class::create_mirror
对象初始化内存分配
UseTLAB -> allocate on TLAB
allow_shared_alloc -> allocate on Edan via cmpxchg
slow_case -> InterpreterRuntime::_new -> InstanceKlass::allocate_instance

YGC
GenCollectedHeap::do_collection -> Generation::collect -> GenCollectedHeap::gen_process_roots(根直接引用)-> GenCollectedHeap::process_roots(年轻代)
                                                                                                       -> CardTableRS::younger_refs_iterate(年老代)
                                                       -> FastEvacuateFollowersClosure::do_void(根间接引用)
GenCollectedHeap::process_roots:
•Universe::oops_do（）：主要是将 Universe:initialize_basic_type_mirrors（）函数中创建基本类型的 mirror 的 instanceOop 实例（表示 java.lang.Class 对象）作为根遍历。
•JNIHandles::oops_do（）：遍历全局 JNI 句柄引用的 oop。
•Threads::possibly_parallel_oops_do（）或 Threads::oops_do（）：这两个函数会遍历 Java 的解释栈和编译栈。Java 线程在解释执行 Java 方法时，每个 Java 方法对应一个调用栈帧，这些栈桢的结构基本固定，栈帧中含有本地变量表。
另外，在一些可定位的位置上还固定存储着一些对 oop 的引用（如监视器对象），垃圾收集器会遍历这些解释栈中引用的o0p 并进行处理。Java 线程在编译执行 Java 方法时，编译执行的汇编代码是由编译器生成的，同一个方法在不同的编译级别下产生的汇编代码可能不一样，因此编译器生成的汇编代码会使用一个单独的 OopMap记录栈帧中引用的 oop，以保存汇编代码的 CodeBlob 通过 OopMapSet 保存的所有 OopMap，可通过栈帧的基地址获取对应的 OopMap，然后遍历编译栈中引用的所有 oop。
•ObjectSynchronizer::oops_do（）：ObjectSynchronizer 中维护的与监视器锁关联的 oop。
•FlatProfiler::oops_do（）：遍历所有线程中的 ThreadProfiler，在 OpenJDK 9 中已弃用 FlatProfiler。
•Management::oops_do（）：MBean 所持有的对象。
•JvmtiExport:oops_do（）：JVMTI 导出的对象、断点或者对象分配事件收集器的相关对象。
•SystemDictionary::oops_do（）或 SystemDictionary:always_strong_oops_do（）：System Dictionary 是系统字典，记录了所有加载的 Klass，通过 Klass 名称和类加载器可以唯一确定一个 Klass 实例。
•ClassLoaderDataGraph::oops_do（）或 ClassLoaderDataGraph:always_strong_oops_do（）：每个 ClassLoader 实例都对应一个 ClassLoaderData，后者保存了前者加载的所有 Klass、加载过程中的依赖和常量池引用。可以通过 ClassLoaderDataGraph 遍历所有的 ClassLoaderData 实例。
•StringTable::possibly_parallel_oops_do（）或 StringTable::oops_do（）：StringTable 用来支持字符串驻留。
•CodeCache::scavenge_root_nmethods_do（）或 CodeCache::blobs_do（）：CodeCache 代码引用。

FastScanClosure(with barrier or with no barrier) 用于ygc复制操作，对象头有转发指针

FGC
