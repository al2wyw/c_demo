synchronized锁和monitor指令
uncommon trap
reallocation
DTRACE_MONITOR_PROBE

自研备注:
锁机制
OopMark  偏向(UseBiasedLocking太复杂)
BasicObjectLock 轻量级
ObjectMonitor  重量级(包含自旋)

异常机制
athrow      explicit_exception
TemplateInterpreter::_throw_XXXException_entry from bytecode asm    explicit_exception
StubRoutines::_throw_XXXException_entry from compiled asm    explicit_exception
asm inst: test/comp SIGSEGV SIGFPE (这里用到了信号机制)      implicit_exception

解释执行:
athrow => jump _throw_exception_entry
xxx exception handler(TemplateInterpreter::_throw_XXXException_entry) => generate_exception_handler => create_exception, jump _throw_exception_entry
xxx exception handler(TemplateInterpreter::_throw_XXXException_entry) => generate_XXXException_handler => throw_XXXException
InterpreterRuntime::create_exception => thread->set_vm_result
InterpreterRuntime::throw_XXXException => THROW => thread->set_pending_exception (call_VM_base check pending exception and jump forward_exception_entry)
TemplateInterpreter::_throw_exception_entry => jump return of InterpreterRuntime::exception_handler_for_exception => the bci address of exception handler table in current java method or
                                                                                                                     the _remove_activation_entry => jump return of exception_handler_for_return_address
StubRoutines::forward_exception_entry => jump return of exception_handler_for_return_address
InterpreterRuntime::throw_pending_exception do nothing

编译执行:
C1 athrow => jmp RuntimeStub - unwind_exception Runtime1 stub => exception_handler_for_return_address
C2 athrow => (opt) call UncommonTrapBlob
          => (deopt) jmp RuntimeStub - _rethrow_Java => exception_handler_for_return_address

Exception Handler C1
call RuntimeStub - handle_exception_from_callee Runtime1 stub => jmp the return of Runtime1::exception_handler_for_pc => SharedRuntime::compute_compiled_exc_handler
call 0x00007ffff647fdd8 看源码handle_exception_from_callee应该没有后续这个call调用 ???

Exception Handler C2
jmp ExceptionBlob => jmp the return of OptoRuntime::handle_exception_C => SharedRuntime::compute_compiled_exc_handler

SharedRuntime::compute_compiled_exc_handler => the address of exception handler (ExceptionTable is a list of handler addr, handler addr is a code addr in main code not Exception Handler(such like block B1 [16, 38])) in current nmethod or
                                               the address of unwind handler => jmp RuntimeStub - unwind_exception Runtime1 stub

StubRoutines::_throw_XXXException_entry => generate_throw_exception => throw_XXXException, forward_exception_entry
SharedRuntime::throw_XXXException => Exceptions::_throw => thread->set_pending_exception
StubRoutines::forward_exception_entry => jump return of exception_handler_for_return_address

公共:
JVM_handle_linux_signal => (interp) TemplateInterpreter::_throw_XXXException_entry
                        => (comp) StubRoutines::_throw_XXXException_entry or nmethod::continuation_for_implicit_exception (ImplicitExceptionTable is a map: pc offset (where exception happened) to implicit exception stub addr in main code(such like ImplicitNullCheckStub))

SharedRuntime::exception_handler_for_return_address => (interp) TemplateInterpreter::_rethrow_exception_entry (include _throw_exception_entry asm code)
                                                    => (comp) nmethod::exception_begin (Exception Handler)
                                                    => (comp) StubRoutines::_catch_exception_entry for _call_stub_return_address


安全点机制
解析执行进入安全点: InterpreterRuntime::at_safepoint 后续是jvmti的逻辑(JvmtiExport::post_single_step把线程加入到待暂停的列表中，最终会调用JvmtiEnv::SuspendThread函数)
编译执行进入安全点: JVM_handle_linux_signal => SharedRuntime::get_poll_stub => SharedRuntime::polling_page_return_handler_blob()->entry_point()
native执行进入安全点: native方法执行完毕后检查是否要进入安全点 => transition_from_native => JavaThread::check_safepoint_and_suspend_for_native_trans()

获取对象锁、park、sleep被blocked的线程会判断安全点吗？ 会的，io rw不会
在进入block时: ThreadBlockInVM() -> transition_and_fence 通过 SafepointSynchronize::do_call_back 的判断会调用 SafepointSynchronize::block
在离开block时: ~ThreadBlockInVM() -> transition_and_fence

deopt的过程
触发点: class加载导致class hiera改变；redefine class；UncommonTrap exception；...
1. SystemDictionary::add_to_hierarchy(class hierarchy改变) -> 进入安全点，push original return addr, patch the return pc to depot handler code
2. depot handler code -> SharedRuntime::generate_deopt_blob   -> Deoptimization::fetch_unroll_info
                                                              -> Deoptimization::unpack_frames
                                                              -> ret (original return addr)

memory order机制
four primitive memory barrier operations:
Load1(s); LoadLoad; Load2: Loads before Load1 may *not* float below Load2
Store1(s); StoreStore; Store2: Stores before Store1 may *not* float below Store2
Load1(s); LoadStore; Store2: Loads before Load1 may *not* float below Store2
Store1(s); StoreLoad; Load2: Stores before Store1 may *not* float below Load2

|     memory accesses      | ^
|------- release  ---------| |  StoreStore
      memory accesses -------|
|------- acquire  ---------| |  LoadLoad/LoadStore
|     memory accesses      | V
fence = release + acquire       StoreLoad
load_acquire = acquire + read variable; release_store = release + write variable; store_fence = fence + write variable
why StoreStore is release and LoadLoad/LoadStore is acquire:(from java并发编程的艺术)
normal r/w StoreStore volatile w StoreLoad
volatile r LoadLoad LoadStore normal r/w
jdk15的StoreStore、LoadLoad、LoadStore、release、acquire全部变成 __asm__ volatile ("" : : : "memory"); (编译器屏障)

模版解释执行 volatile for x86:(参考cpu架构允许的重排序)
putField:
// volatile_barrier(LoadStore|StoreStore) no need for x86
put value to field
volatile_barrier(StoreLoad|StoreStore)
getField:
get value from field
// volatile_barrier((LoadLoad |LoadStore) no need for x86

volatile_barrier:
if os::is_MP() {if StoreLoad { lock addl $0x0,(%rsp);}} //只有StoreLoad有额外操作

内存分配及回收:
卡表、偏移表、写屏障/读屏障 (共同协作以解决跨代引用问题)
卡表: CardTableRS extends GenRemSet
卡表是一个字节的集合，每一个字节可以用来表示老年代某一区域中的对象是否持有新生代对象的引用。每个卡表项对应一个卡页，卡页（Card Page）大小为512字节。
偏移表: BlockOffsetSharedArray
偏移表记录脏卡页中第一个对象相对卡页开始地址的偏移量
写(前/后)屏障: CardTableModRefBSForCTRS
内存写入时的拦截器(执行前置后置动作)，例如内存更新时同时更新卡表为脏
三色标记法: 黑色(已标记完) 灰色(开始标记) 白色(未标记)
错标: 原本消亡的对象标记为存活，问题不大，仅产生浮动垃圾
漏标: 原来存活的对象未被标记，问题严重，其产生的原因(同时命中) 1. 新增黑色到某个白色的引用；2. 删除了全部灰色到白色(1中的白色)的引用
增量更新解决原因1，原始快照解决原因2 (都是通过写后屏障来实现)

类初始化内存分配
ClassFileParser::parseClassFile ->  InstanceKlass::allocate_instance_klass
                                    java_lang_Class::create_mirror
对象初始化内存分配
UseTLAB -> allocate on TLAB (TLAB is on edan and allocate new TLAB when it is consumed)
allow_shared_alloc -> allocate on Edan via cmpxchg
slow_case -> InterpreterRuntime::_new -> InstanceKlass::allocate_instance

YGC: Generation is DefNewGeneration
GenCollectedHeap::do_collection -> Generation::collect -> GenCollectedHeap::gen_process_roots(根直接引用)-> GenCollectedHeap::process_roots(年轻代)
                                                                                                       -> CardTableRS::younger_refs_iterate(年老代)
                                                       -> FastEvacuateFollowersClosure::do_void(根间接引用)

FastScanClosure(with barrier or with no barrier)::do_oop_work 用于ygc复制操作(会判断oop是否在年轻代)，对象头有转发指针，同时写屏障标记年老代卡页是否为脏

GenCollectedHeap::process_roots: (年轻代主要是从各个地方扫描出所有的根oop)
•Universe::oops_do（）：主要是将 Universe:initialize_basic_type_mirrors（）函数中创建基本类型的 mirror 的 instanceOop 实例（表示 java.lang.Class 对象）作为根遍历。
•JNIHandles::oops_do（）：遍历全局 JNI 句柄引用的 oop。
•Threads::possibly_parallel_oops_do（）或 Threads::oops_do（）：这两个函数会遍历 Java 的解释栈和编译栈。Java 线程在解释执行 Java 方法时，每个 Java 方法对应一个调用栈帧，这些栈桢的结构基本固定，栈帧中含有本地变量表。
另外，在一些可定位的位置上还固定存储着一些对 oop 的引用（如监视器对象），垃圾收集器会遍历这些解释栈中引用的o0p 并进行处理。Java 线程在编译执行 Java 方法时，编译执行的汇编代码是由编译器生成的，同一个方法在不同的编译级别下产生的汇编代码可能不一样，因此编译器生成的汇编代码会使用一个单独的 OopMap记录栈帧中引用的 oop，以保存汇编代码的 CodeBlob 通过 OopMapSet 保存的所有 OopMap，可通过栈帧的基地址获取对应的 OopMap，然后遍历编译栈中引用的所有 oop。
•ObjectSynchronizer::oops_do（）：ObjectSynchronizer 中维护的与监视器锁关联的 oop。
•FlatProfiler::oops_do（）：遍历所有线程中的 ThreadProfiler，在 OpenJDK 9 中已弃用 FlatProfiler。
•Management::oops_do（）：MBean 所持有的对象。
•JvmtiExport:oops_do（）：JVMTI 导出的对象、断点或者对象分配事件收集器的相关对象。
•SystemDictionary::oops_do（）或 SystemDictionary:always_strong_oops_do（）：System Dictionary 是系统字典，记录了所有加载的 Klass，通过 Klass 名称和类加载器可以唯一确定一个 Klass 实例。
•ClassLoaderDataGraph::oops_do（）或 ClassLoaderDataGraph:always_strong_oops_do（）：每个 ClassLoader 实例都对应一个 ClassLoaderData，后者保存了前者加载的所有 Klass、加载过程中的依赖和常量池引用。可以通过 ClassLoaderDataGraph 遍历所有的 ClassLoaderData 实例。
•StringTable::possibly_parallel_oops_do（）或 StringTable::oops_do（）：StringTable 用来支持字符串驻留。
•CodeCache::scavenge_root_nmethods_do（）或 CodeCache::blobs_do（）：CodeCache 代码引用。

CardTableRS::younger_refs_iterate: (年老代主要是从脏卡里的oop的引用中扫描出根oop)
Filtering_DCTOC::walk_mem_region
ContiguousSpaceDCTOC::walk_mem_region_with_cl
oopDesc::oop_iterate
InstanceKlass::oop_oop_iterate_nv (从InstanceKlass的oop map block快速读取实例所引用的oop)

FastEvacuateFollowersClosure::do_void: (年轻代直接从to space开始遍历，跳过eden和from区; 年老代主要是遍历刚刚晋升过来的新oop)
ContiguousSpace::oop_since_save_marks_iterate_nv
oopDesc::oop_iterate
InstanceKlass::oop_oop_iterate_nv

FGC: Generation is TenuredGeneration plus(maybe) DefNewGeneration
GenCollectedHeap::do_full_collection -> GenCollectedHeap::do_collection -> Generation::collect -> GenMarkSweep::invoke_at_safepoint -> GenMarkSweep::mark_sweep_phase1 标记所有活跃对象 GenCollectedHeap::gen_process_roots -> FollowRootClosure
                                                                                                                                    -> GenMarkSweep::mark_sweep_phase2 计算所有活跃对象在压缩后的偏移地址 Generation::prepare_for_compaction -> ContiguousSpace::prepare_for_compaction (主要是计算出所有的LiveRange)
                                                                                                                                    -> GenMarkSweep::mark_sweep_phase3 更新对象的引用地址 GenCollectedHeap::gen_process_roots  -> AdjustPointerClosure (根直接引用)
                                                                                                                                                                                       GenCollectedHeap::generation_iterate -> AdjustPointersClosure (根间接引用，直接遍历各年代的空间，此时是可解析的)
                                                                                                                                    -> GenMarkSweep::mark_sweep_phase4 移动所有活跃对象到新的位置 GenCollectedHeap::generation_iterate -> GenCompactClosure
                                                                                                                                    -> MarkSweep::restore_marks 恢复另存的mark对象头信息到源oop
                                                                                                                                    -> CardTableRS::invalidate_or_clear 更新卡表信息

FollowRootClosure::do_oop 不会进行年代边界判断，标记完当前oop后调用 follow_contents(oop的引用) 和 follow_stack 进行递归全量标记，同时另存mark对象头信息

LiveRange 存储在死亡对象的开始位置，通过 LiveRange 的start和end可快速定位到下一个活跃对象的区
                      LiveRange----start-------end
LiveRange----start-------end
    |---dead---|---live---|---dead---|---live---|

AdjustPointerClosure::do_oop 更新mark为转发指针，即对象头有转发指针

AdjustPointersClosure::do_space: 批量更新mark为转发指针，即对象头有转发指针
Space::adjust_pointers
oopDesc::adjust_pointers
InstanceKlass::oop_adjust_pointers

GenCompactClosure::do_generation 拷贝旧oop数据到转发地址对应的新地址
Generation::compact
CompactibleSpace::compact

CMS:
CMSCollector::collect_in_background:

CMSCollector::checkpointRootsInitialWork

CMSCollector::markFromRoots

CMSCollector::preclean

CMSCollector::abortable_preclean

CMSCollector::checkpointRootsFinal

CMSCollector::sweep

G1:
