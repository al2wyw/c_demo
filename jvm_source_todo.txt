synchronized锁和monitor指令
DTRACE_MONITOR_PROBE

自研备注:
锁机制
OopMark  偏向(UseBiasedLocking太复杂)
BasicObjectLock 轻量级
ObjectMonitor  重量级(包含自旋)

由于jvm使用code patching技术，所以LogCompilation打印出来的code并不一定是最终执行的code !!!
异常机制:
athrow      explicit_exception
TemplateInterpreter::_throw_XXXException_entry from bytecode asm    explicit_exception
StubRoutines::_throw_XXXException_entry from compiled asm    explicit_exception
asm inst: test/comp/div SIGSEGV SIGFPE (这里用到了信号机制)      implicit_exception

解释执行:
athrow => jump _throw_exception_entry
xxx exception handler(TemplateInterpreter::_throw_XXXException_entry) => generate_exception_handler => create_exception, jump _throw_exception_entry
xxx exception handler(TemplateInterpreter::_throw_XXXException_entry) => generate_XXXException_handler => throw_XXXException
InterpreterRuntime::create_exception => thread->set_vm_result
InterpreterRuntime::throw_XXXException => THROW => thread->set_pending_exception (call_VM_base check pending exception and jump forward_exception_entry)
TemplateInterpreter::_throw_exception_entry => jump return of InterpreterRuntime::exception_handler_for_exception => the bci address of exception handler table in current java method or
                                                                                                                     the _remove_activation_entry => jump return of exception_handler_for_return_address
StubRoutines::forward_exception_entry => jump return of exception_handler_for_return_address
InterpreterRuntime::throw_pending_exception do nothing

编译执行:
C1 athrow => jmp RuntimeStub - unwind_exception Runtime1 stub(Runtime1::generate_unwind_exception) => exception_handler_for_return_address
C1 athrow => call RuntimeStub - handle_exception_nofpu Runtime1 stub(Runtime1::generate_handle_exception 有多种不同的 handle_exception ???)
C1 implicit exception dispatches to call stub addr
-Xcomp:
C2 athrow => (opt) call UncommonTrapBlob
          => (deopt) jmp RuntimeStub - _rethrow_Java => exception_handler_for_return_address
正常profile:
C2 athrow => jmp RuntimeStub - _rethrow_Java (全走rethrow，无论什么exception，而且没有UncommonTrap)

Exception Handler C1
call RuntimeStub - handle_exception_from_callee Runtime1 stub => jmp the return of Runtime1::exception_handler_for_pc => SharedRuntime::compute_compiled_exc_handler
call 0x00007ffff647fdd8 看源码handle_exception_from_callee应该没有后续这个call调用 ???

Exception Handler C2
jmp ExceptionBlob => jmp the return of OptoRuntime::handle_exception_C => SharedRuntime::compute_compiled_exc_handler

SharedRuntime::compute_compiled_exc_handler => the address of exception handler from ExceptionTable in current nmethod or
                                               the address of unwind handler => jmp RuntimeStub - unwind_exception Runtime1 stub
                                               (ExceptionTable is a list of handler addr, handler addr is a code addr in main code not Exception Handler(such like block B1 [16, 38]))

StubRoutines::_throw_XXXException_entry => generate_throw_exception => throw_XXXException, forward_exception_entry
SharedRuntime::throw_XXXException => Exceptions::_throw => thread->set_pending_exception
StubRoutines::forward_exception_entry => jump return of exception_handler_for_return_address

公共:
JVM_handle_linux_signal => (interp) TemplateInterpreter::_throw_XXXException_entry
                        => (comp) StubRoutines::_throw_XXXException_entry or nmethod::continuation_for_implicit_exception
                        (ImplicitExceptionTable(C2 has no IET) is a map: pc offset (where exception happened) to implicit exception stub addr in main code(such like ImplicitNullCheckStub))

SharedRuntime::exception_handler_for_return_address => (interp) TemplateInterpreter::_rethrow_exception_entry (include _throw_exception_entry asm code)
                                                    => (comp) nmethod::exception_begin (Exception Handler)
                                                    => (comp) StubRoutines::_catch_exception_entry for _call_stub_return_address


安全点机制(5种场景)
1. 解析执行进入安全点: Interpreter::notice_safepoints() => copy_table(&_safept_table, &_active_table) ====> InterpreterRuntime::at_safepoint => IRT_ENTRY
2. 编译执行进入安全点: os::make_polling_page_unreadable() => linux_mprotect(addr, size, PROT_NONE) ====> JVM_handle_linux_signal => SharedRuntime::get_poll_stub => SharedRuntime::polling_page_return_handler_blob()->entry_point()
3. native执行进入安全点: native方法执行完毕后检查是否要进入安全点 => transition_from_native => JavaThread::check_safepoint_and_suspend_for_native_trans()
4. blocked的线程: 获取对象锁、park、sleep被blocked的线程会判断安全点吗？ 会的，io rw不会:
4.1. 在进入block时: ThreadBlockInVM() -> transition_and_fence 通过 SafepointSynchronize::do_call_back 的判断会调用 SafepointSynchronize::block
4.2. 在离开block时: ~ThreadBlockInVM() -> transition_and_fence
5. In VM or Transitioning between states: the thread will block itself when it attempts transitions to a new state
5.1. IRT_ENTRY => ThreadInVMfromJava => transition
5.2. JVM_ENTRY => ThreadInVMfromNative => transition_and_fence

deopt的过程
触发点: class加载导致class hierarchy改变；redefine class；uncommon trap exception；...

class加载导致class hierarchy改变:
1. SystemDictionary::add_to_hierarchy(class hierarchy改变) -> 进入安全点，VM_Deoptimize::doit -> Deoptimization::deoptimize_dependents
2. Deoptimization::deoptimize_dependents -> Deoptimization::deoptimize -> frame::deoptimize -> push original return addr, patch the return pc to depot handler code
3. depot handler code -> SharedRuntime::generate_deopt_blob   -> Deoptimization::fetch_unroll_info(return UnrollBlock*) -> Deoptimization::fetch_unroll_info_helper
                                                              -> Deoptimization::unpack_frames
                                                              -> ret (original return addr)

redefine class:
1. JvmtiEnv::RedefineClasses or JvmtiEnv::RetransformClasses -> 进入安全点，VM_RedefineClasses::doit -> VM_RedefineClasses::redefine_single_class -> Deoptimization::deoptimize_dependents

uncommon trap exception:
1. UncommonTrapBlob -> Deoptimization::uncommon_trap(return UnrollBlock*) -> Deoptimization::fetch_unroll_info_helper
                    -> Deoptimization::unpack_frames
                    -> return to interpreter

uncommon trap(C2特有)
implicit exception, rare branch hit(Deoptimization::DeoptReason) => jmp other code addr to call UncommonTrapBlob
对比opt和deopt后的代码好像没有什么区别(除了call UncommonTrapBlob被替换成真正的处理逻辑)，那uncommon trap的机制有什么作用 ???

memory order机制
four primitive memory barrier operations:
Load1(s); LoadLoad; Load2: Loads before Load1 may *not* float below Load2
Store1(s); StoreStore; Store2: Stores before Store1 may *not* float below Store2
Load1(s); LoadStore; Store2: Loads before Load1 may *not* float below Store2
Store1(s); StoreLoad; Load2: Stores before Store1 may *not* float below Load2

|     memory accesses      | ^
|------- release  ---------| |  StoreStore
      memory accesses -------|
|------- acquire  ---------| |  LoadLoad/LoadStore
|     memory accesses      | V
fence = release + acquire       StoreLoad
load_acquire = acquire + read variable; release_store = release + write variable; store_fence = fence + write variable
why StoreStore is release and LoadLoad/LoadStore is acquire:(from java并发编程的艺术)
normal r/w StoreStore volatile w StoreLoad
volatile r LoadLoad LoadStore normal r/w
jdk15的StoreStore、LoadLoad、LoadStore、release、acquire全部变成 __asm__ volatile ("" : : : "memory"); (编译器屏障)

模版解释执行 volatile for x86:(参考cpu架构允许的重排序)
putField:
// volatile_barrier(LoadStore|StoreStore) no need for x86
put value to field
volatile_barrier(StoreLoad|StoreStore)
getField:
get value from field
// volatile_barrier((LoadLoad |LoadStore) no need for x86

volatile_barrier:
if os::is_MP() {if StoreLoad { lock addl $0x0,(%rsp);}} //只有StoreLoad有额外操作

内存分配及回收:
卡表、偏移表、写屏障/读屏障 (共同协作以解决跨代引用问题)
卡表: CardTableRS extends GenRemSet
卡表是一个字节的集合，每一个字节可以用来表示老年代某一区域中的对象是否持有新生代对象的引用(字节用来标识各种状态)。每个卡表项对应一个卡页，卡页（Card Page）大小为512字节。
偏移表: BlockOffsetSharedArray
偏移表记录脏卡页中第一个对象相对卡页开始地址的偏移量
写(前/后)屏障: CardTableModRefBSForCTRS
内存写入时的拦截器(执行前置后置动作)，例如内存更新时同时更新卡表为脏
三色标记法: 黑色(已标记完) 灰色(开始标记) 白色(未标记)
错标: 原本消亡的对象标记为存活，问题不大，仅产生浮动垃圾
漏标: 原来存活的对象未被标记，问题严重，其产生的原因(同时命中) 1. 新增黑色到某个白色的引用；2. 删除了全部灰色到白色(1中的白色)的引用
增量更新解决原因1，原始快照解决原因2 (都是通过写后屏障来实现)

全局内存初始化
ReservedSpace to reserve virtual address in advance:
universe_init -> Universe::initialize_heap -> GenCollectedHeap::initialize -> GenCollectedHeap::allocate -> Universe::reserve_heap(return ReservedSpace)
ReservedSpace::initialize(large is false, large page memory大页内存) -> os::reserve_memory -> mmap(PROT_NONE)
VirtualSpace holds ReservedSpace to perform commit and pre-touch:
DefNewGeneration::compute_new_size -> DefNewGeneration::expand -> VirtualSpace::expand_by -> os::commit_memory -> mmap(PROT_READ|PROT_WRITE)

类初始化内存分配
ClassFileParser::parseClassFile ->  InstanceKlass::allocate_instance_klass (Allocate in meta)
                                    java_lang_Class::create_mirror (Allocate mirror and initialize static fields in heap)
对象初始化内存分配 (Allocate in heap)
UseTLAB -> allocate on TLAB (TLAB is on edan and allocate new TLAB when it is consumed，TLAB will be filled with memory when oop is allocated)
allow_shared_alloc -> allocate on Edan via cmpxchg (only DefNewGeneration allowed)
slow_case -> InterpreterRuntime::_new -> InstanceKlass::allocate_instance

YGC: Generation is DefNewGeneration
GenCollectedHeap::do_collection -> Generation::collect -> GenCollectedHeap::gen_process_roots(根直接引用)-> GenCollectedHeap::process_roots(年轻代) -> FastScanClosure::do_oop_work
                                                                                                       -> CardTableRS::younger_refs_iterate(年老代到年轻代的引用) -> FastScanClosure::do_oop_work
                                                       -> FastEvacuateFollowersClosure::do_void(根间接引用)

FastScanClosure(with barrier or with no barrier)::do_oop_work 用于ygc复制操作(会判断oop是否在年轻代)，对象头有转发指针，同时写屏障标记年老代卡页是否为脏
FastScanClosure::do_oop_work -> DefNewGeneration::copy_to_survivor_space -> to()->allocate_aligned copy到to区 or _next_gen->promote 晋升到next gen

GenCollectedHeap::process_roots: (年轻代主要是从各个地方扫描出所有的根oop)
•Universe::oops_do（）：主要是将 Universe:initialize_basic_type_mirrors（）函数中创建基本类型的 mirror 的 instanceOop 实例（表示 java.lang.Class 对象）作为根遍历。
•JNIHandles::oops_do（）：遍历全局 JNI 句柄引用的 oop。
•Threads::possibly_parallel_oops_do（）或 Threads::oops_do（）：这两个函数会遍历 Java 的解释栈和编译栈。Java 线程在解释执行 Java 方法时，每个 Java 方法对应一个调用栈帧，这些栈桢的结构基本固定，栈帧中含有本地变量表。
另外，在一些可定位的位置上还固定存储着一些对 oop 的引用（如监视器对象），垃圾收集器会遍历这些解释栈中引用的o0p 并进行处理。Java 线程在编译执行 Java 方法时，编译执行的汇编代码是由编译器生成的，同一个方法在不同的编译级别下产生的汇编代码可能不一样，因此编译器生成的汇编代码会使用一个单独的 OopMap记录栈帧中引用的 oop，以保存汇编代码的 CodeBlob 通过 OopMapSet 保存的所有 OopMap，可通过栈帧的基地址获取对应的 OopMap，然后遍历编译栈中引用的所有 oop。
•ObjectSynchronizer::oops_do（）：ObjectSynchronizer 中维护的与监视器锁关联的 oop。
•FlatProfiler::oops_do（）：遍历所有线程中的 ThreadProfiler，在 OpenJDK 9 中已弃用 FlatProfiler。
•Management::oops_do（）：MBean 所持有的对象。
•JvmtiExport:oops_do（）：JVMTI 导出的对象、断点或者对象分配事件收集器的相关对象。
•SystemDictionary::oops_do（）或 SystemDictionary:always_strong_oops_do（）：System Dictionary 是系统字典，记录了所有加载的 Klass，通过 Klass 名称和类加载器可以唯一确定一个 Klass 实例。
•ClassLoaderDataGraph::oops_do（）或 ClassLoaderDataGraph:always_strong_oops_do（）：每个 ClassLoader 实例都对应一个 ClassLoaderData，后者保存了前者加载的所有 Klass、加载过程中的依赖和常量池引用。可以通过 ClassLoaderDataGraph 遍历所有的 ClassLoaderData 实例。
•StringTable::possibly_parallel_oops_do（）或 StringTable::oops_do（）：StringTable 用来支持字符串驻留。
•CodeCache::scavenge_root_nmethods_do（）或 CodeCache::blobs_do（）：CodeCache 代码引用。
Thread 有 resource_area、active_handles(JNI)和handle_area，Thread::oops_do负责回收active_handles和handle_area，resource_area靠ResourceMark维护

CardTableRS::younger_refs_iterate: (年老代主要是从脏卡里的oop的引用中扫描出根oop)
Filtering_DCTOC::walk_mem_region
ContiguousSpaceDCTOC::walk_mem_region_with_cl
oopDesc::oop_iterate (返回oop size)
InstanceKlass::oop_oop_iterate_nv (从InstanceKlass的oop map block快速读取实例所引用的oop，OopMapBlock记录当前oop引用的obj field offset和field数量，每个oop有多个OopMapBlock是因为每个klass有一个OopMapBlock(类继承导致))
FastScanClosure::do_oop_work (with barrier)

FastEvacuateFollowersClosure::do_void: (年轻代直接从to space开始遍历，跳过eden和from区; 年老代主要是遍历刚刚晋升过来的新oop)
年轻代:
ContiguousSpace::oop_since_save_marks_iterate_nv
    oopDesc::oop_iterate
    InstanceKlass::oop_oop_iterate_nv
    FastScanClosure::do_oop_work (with no barrier) (如果复制到to区，to区的top会变大)
年老代:
ContiguousSpace::oop_since_save_marks_iterate_nv
    oopDesc::oop_iterate
    InstanceKlass::oop_oop_iterate_nv
    FastScanClosure::do_oop_work (with barrier)

YGC: Generation is ParNewGeneration (其他与DefNewGeneration保持一致)
ParNewGenTask::work 任务起始，多个GangWorker(WorkerThread)通过ParScanThreadState的work_queue协作进行垃圾回收, 通过GenCollectedHeap::process_roots的is_task_claimed协作进行root扫描任务
ParScanClosure(with barrier or with no barrier)
ParScanClosure::do_oop_work -> ParNewGeneration::copy_to_survivor_space -> to_space_alloc_buffer()->allocate_aligned copy到to区的ParGCAllocBuffer(PLAB,线程独占) or _next_gen->par_promote 晋升到next gen的local allocation buffer(CFLS_LAB,线程独占)
                                                                        -> par_scan_state->work_queue()->push(obj_to_push) or ParNewGeneration::push_on_overflow_list()
ParScanThreadState::alloc_in_to_space_slow ->  Space::par_allocate
                                               ParGCAllocBuffer::set_buf // PLAB的内存分配，从Space线性分配

                                               CFLS_LAB::  ??? // CFLS_LAB的内存分配

ParEvacuateFollowersClosure::do_void(根间接引用,实现方式不同)
ParScanThreadState::trim_queues(0) //Scan to-space and old-gen objs -> ParScanClosure::do_oop_work
task_queues()->steal //steal from other thread, go back to trim_queues
ParNewGeneration::take_from_overflow_list //steal from global overflow list, go back to trim_queues
task_queue 就是 work_queue，ParNewGeneration::collect 有初始化逻辑

FGC: Generation is TenuredGeneration plus(maybe) DefNewGeneration
GenCollectedHeap::do_full_collection -> GenCollectedHeap::do_collection -> Generation::collect -> GenMarkSweep::invoke_at_safepoint -> GenMarkSweep::mark_sweep_phase1 标记所有活跃对象 GenCollectedHeap::gen_process_roots -> FollowRootClosure
                                                                                                                                    -> GenMarkSweep::mark_sweep_phase2 计算所有活跃对象在压缩后的偏移地址 Generation::prepare_for_compaction -> ContiguousSpace::prepare_for_compaction (主要是计算出所有的LiveRange)
                                                                                                                                    -> GenMarkSweep::mark_sweep_phase3 更新对象的引用地址 GenCollectedHeap::gen_process_roots  -> AdjustPointerClosure (根直接引用)
                                                                                                                                                                                       GenCollectedHeap::generation_iterate -> AdjustPointersClosure (根间接引用，直接遍历各年代的空间，此时是可解析的)
                                                                                                                                    -> GenMarkSweep::mark_sweep_phase4 移动所有活跃对象到新的位置 GenCollectedHeap::generation_iterate -> GenCompactClosure
                                                                                                                                    -> MarkSweep::restore_marks 恢复另存的mark对象头信息到源oop
                                                                                                                                    -> CardTableRS::invalidate_or_clear 更新卡表信息

FollowRootClosure::do_oop 不会进行年代边界判断，标记完当前oop后调用 follow_contents(oop的引用) 和 follow_stack 进行递归全量标记，同时另存mark对象头信息

LiveRange 存储在死亡对象的开始位置，通过 LiveRange 的start和end可快速定位到下一个活跃对象的区
                      LiveRange----start-------end
LiveRange----start-------end
    |---dead---|---live---|---dead---|---live---|

AdjustPointerClosure::do_oop 更新mark为转发指针，即对象头有转发指针

AdjustPointersClosure::do_space: 批量更新mark为转发指针，即对象头有转发指针
Space::adjust_pointers
oopDesc::adjust_pointers
InstanceKlass::oop_adjust_pointers

GenCompactClosure::do_generation 拷贝旧oop数据到转发地址对应的新地址
Generation::compact
CompactibleSpace::compact


ParallelScavenge: (和以上完全不一样的另一套实现方式)

CMS:
CMS free list: FreeList head -> FreeChunk <=> FreeChunk <- tail FreeList
LinearAllocBlock ???
AdaptiveFreeList(size < 257) size as index -> free chuck list
BinaryTreeDictionary(size >= 257) size as key -> free chuck list
小块的chunk来自于大块chunk的spilt，初始化时整块内存作为一个chunk给了BinaryTreeDictionary

BlockOffsetArrayNonContigSpace 脏卡 block offset table ???


CMSCollector::collect_in_background:

1. CMSCollector::checkpointRootsInitialWork:
GenCollectedHeap::gen_process_roots(根直接引用) -> GenCollectedHeap::process_roots(年老代) -> MarkRefsIntoClosure::do_oop
                                              -> Generation::oop_iterate(年轻代到年老代的引用，可以在idea里面直接查看宏展开) -> oopDesc::oop_iterate -> InstanceKlass::oop_oop_iterate_nv -> MarkRefsIntoClosure::do_oop


MarkRefsIntoClosure::do_oop() -> 判断oop地址是否在mem region然后更新cms bitmap,cms bitmap拥有所有的根直接引用

2. CMSCollector::markFromRoots: 从cms bitmap出发标记所有的根间接引用
MarkFromRootsClosure::do_bit(cms bitmap) -> MarkFromRootsClosure::scanOopsInOop(使用_markStack递归全量标记) -> oopDesc::oop_iterate -> InstanceKlass::oop_oop_iterate_nv -> PushOrMarkClosure::do_oop(更新cms bitmap)

3. CMSCollector::preclean: 主要处理两种场景(被引用的对象晋升或直接分配到年老代，被标记的年老代对象引用关系变化)，配合dirty card机制以减少final mark的时间
clean_refs
preclean_klasses
preclean_card_table ->

4. CMSCollector::abortable_preclean:


5. CMSCollector::checkpointRootsFinal:
CMSCollector::do_remark_non_parallel
CMSCollector::do_remark_parallel

6. CMSCollector::sweep:
CompactibleFreeListSpace::blk_iterate_careful -> SweepClosure::do_blk_careful

G1:
Humongous size = G1HeapRegionSize / 2
YGC: (多个线程各跑各的G1ParTask，根据worker_id分配全局资源)
G1CollectedHeap::do_collection_pause_at_safepoint -> G1CollectedHeap::evacuate_collection_set -> G1ParTask::work -> G1RootProcessor::evacuate_roots -> is_task_claimed -> G1ParCopyClosure::do_oop_work
                                                                                                                 -> G1RootProcessor::scan_remembered_sets -> G1RemSet::oops_into_collection_set_do -> G1RemSet::updateRS -> G1CollectedHeap::iterate_dirty_card_closure -> DirtyCardQueueSet::apply_closure_to_completed_buffer
                                                                                                                                                                                                   -> G1RemSet::scanRS -> ScanRSClosure::doHeapRegion ->
                                                                                                                 -> G1ParEvacuateFollowersClosure::do_void -> G1ParScanThreadState::steal_and_trim_queue -> G1ParScanThreadState::do_oop_evac (same as G1ParCopyClosure::do_oop_work)
                                                  -> G1CollectedHeap::free_collection_set -> ???
                                                  -> ...

G1ParCopyClosure(with barrier or with no barrier)::do_oop_work(会判断oop是否在cset)-> G1ParScanThreadState::copy_to_survivor_space -> G1ParGCAllocator::plab_allocate copy到survivor region的G1ParGCAllocBuffer(PLAB,线程独占) or copy到old region的PLAB
                                                                                                                                 -> G1ParScanThreadState::push_on_queue

RemSet:
DirtyCardQueueSet::apply_closure_to_completed_buffer -> DirtyCardQueue::apply_closure_to_buffer -> RefineRecordRefsIntoCSCardTableEntryClosure::do_card_ptr -> G1RemSet::refine_card -> HeapRegion::oops_on_card_seq_iterate_careful -> G1UpdateRSOrPushRefOopClosure::do_oop
G1UpdateRSOrPushRefOopClosure::do_oop -> G1ParPushHeapRSClosure::do_oop -> G1ParScanThreadState::push_on_queue
                                   or -> HeapRegionRemSet::add_reference -> OtherRegionsTable::add_reference (OtherRegionsTable就是per region CardTableRS，采用三种颗粒度的数据结构进行引用关系记录)

MIX GC: (including G1CollectedHeap::do_collection_pause_at_safepoint, should_start_conc_mark is true)
should_start_conc_mark的触发条件 -> set_initiate_conc_mark_if_possible -> need_to_start_conc_mark -> IHOP
                                                                      ->  force_initial_mark_if_outside_cycle
ConcurrentMarkThread::run -> ConcurrentMark::scanRootRegions -> CMRootRegionScanTask::work -> ConcurrentMark::scanRootRegion -> G1RootRegionScanClosure::do_oop
                          -> ConcurrentMark::markFromRoots() -> CMConcurrentMarkingTask::work -> CMTask::do_marking_step
                          -> CMCheckpointRootsFinalClosure(VM_CGC_Operation) -> ConcurrentMark::checkpointRootsFinal -> CMTask::do_marking_step
                          -> CMCleanUp(VM_CGC_Operation) -> ConcurrentMark::cleanup()
copy step (stw)???

G1RootRegionScanClosure::do_oop

CMTask::do_marking_step

FGC:
G1CollectedHeap::do_full_collection ->

string去重: +XX:UseStringDeduplication
G1StringDedup::enqueue_from_mark